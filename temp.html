<style>
/* line 2, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.intrinsic-wrapper.loaded {
  position: relative;
  padding-top: 66%;
}
/* line 7, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.intrinsic-wrapper.closed {
  display: none;
}

/* line 11, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
body.closed {
  height: 0px;
  display: inline;
}

/* line 15, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#firehose-container {
  font-family: "nyt-franklin", arial, helvetica, sans-serif;
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 20px;
  color: #fff;
  text-align: center;
  overflow: visible;
  background: transparent;
}
/* line 27, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#firehose-container.open {
  top: 0;
  left: 0;
  height: 100%;
  position: absolute;
  width: 100%;
}
/* line 35, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#firehose-container.closed {
  display: none;
}

/* line 50, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.wc-firehose {
  height: 100%;
  color: #666;
  margin: 0 auto;
  position: relative;
}

/* line 56, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.wc-firehose img {
  width: 100%;
  height: auto;
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
}

/* line 65, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.photo-container {
  position: absolute;
  top: 0px;
  right: 60px;
  bottom: 0px;
  left: 0px;
}

/* line 72, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#photo1, #photo2, .placeholder {
  width: 100%;
  height: 95%;
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  opacity: 0;
  transition: opacity .5s linear, background-color .5s;
}

/* line 83, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.photo {
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

/* line 89, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.wc-firehose h6 {
  font-family: nyt-franklin, "nyt-franklin", arial, helvetica, sans-serif;
  font-size: 14px;
  line-height: 20px;
  color: #666;
  font-weight: normal;
}

/* line 96, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#closed {
  display: none;
}

/* line 99, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#open {
  display: block;
}

/* line 102, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.closed #closed {
  display: block;
}

/* line 105, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.closed #open {
  display: none;
}

/* line 109, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.closed header {
  display: block;
}

/* line 112, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.closed header h1 a {
  display: block;
}

/* line 115, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.closed header h2 {
  display: none;
}

/* line 118, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.closed header ul {
  display: none;
}

/* line 124, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.photo-container {
  position: absolute;
  top: 0px;
  right: 0px;
}

/* line 130, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.photo {
  height: 100%;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
}

/* line 136, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.credit {
  font-family: nyt-franklin, "nyt-franklin", arial, helvetica, sans-serif;
  font-size: 0.5625rem;
  line-height: 18px;
  position: absolute;
  bottom: 0px;
  right: 0;
  color: #bab8b3;
  text-align: right;
  display: block;
}

/* line 208, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.closed {
  background-image: url("static.gif");
  position: relative;
  height: 100%;
  overflow: hidden;
}

/* line 214, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#staticbars {
  z-index: 0;
  height: 450px;
  position: absolute;
  display: block;
  top: -20%;
  left: 0;
  width: 120%;
  -webkit-transition: top 26s linear;
  -moz-transition: top 26s linear;
  -o-transition: top 26s linear;
  -ms-transition: top 26s linear;
  transition: top 26s linear;
  animation-iteration-count: 3;
  -webkit-animation-iteration-count: 3;
}

/* line 230, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#staticbars hr {
  border: none;
  background: rgba(255, 255, 255, 0.03);
  box-shadow: 0 10px 10px rgba(255, 255, 255, 0.03), 0 -10px 10px rgba(255, 255, 255, 0.03);
}

/* line 235, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#staticbars hr.largebar {
  height: 200px;
}

/* line 238, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#staticbars hr.smallbar {
  margin-top: 140px;
  height: 100px;
}

/* line 242, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.loaded #staticbars {
  top: 100%;
}

@media screen and (max-width: 1090px) {
  /* line 247, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  header ul li.live span {
    display: none;
  }
}
@media screen and (max-width: 820px) {
  /* line 254, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  header ul li.email span,
  header ul li.facebook span,
  header ul li.twitter span {
    display: none;
  }

  /* line 260, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  li.logo,
  li.nyt,
  li.live {
    top: -9px;
    position: relative;
  }
}
@media screen and (max-width: 600px) {
  /* line 269, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  header ul li.live,
  header ul li.photos {
    display: none;
  }
}
/*820*/
@media screen and (max-width: 500px) {
  /* line 279, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  #teaser-container {
    min-width: 100%;
    max-width: 100%;
    width: 100%;
    padding: 0;
  }

  /* line 292, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  #message {
    width: 90%;
    margin: auto 5%;
  }

  /* line 296, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  #message h3 {
    white-space: normal;
  }

  /* line 299, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  .credit {
    font-size: 10px;
  }

  /* line 303, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  li.email {
    right: 0;
  }

  /* line 307, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  li.twitter {
    right: 40px;
  }

  /* line 310, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  li.facebook {
    right: 80px;
  }

  /* line 313, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  li.live {
    display: block;
  }

  /* line 316, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  li.live span {
    display: inline-block !important;
  }
}
@media screen and (max-width: 420px) {
  /* line 323, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  li.live span {
    display: none !important;
  }
}
@media print, (-webkit-min-device-pixel-ratio: 1.25), (-o-min-device-pixel-ratio: 5 / 4), (min-device-pixel-ratio: 1.25), (min-resolution: 120dpi) {
  /* line 329, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
  header ul li.nyt a,
  header ul li.email a i,
  header ul li.facebook a i,
  header ul li.twitter a i {
    background-image: url(/assets/firehose_sprite_2x);
    background-repeat: no-repeat;
    -webkit-background-size: 200px 300px;
    -moz-background-size: 200px 300px;
    background-size: 200px 300px;
  }
}
/* line 341, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
.title {
  -webkit-font-smoothing: subpixel-antialiased;
  font-family: "nyt-franklin", helvetica, arial, sans-serif;
  font-weight: 700;
}

/* line 347, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
header ul li.logo a {
  color: white;
  text-decoration: none;
  font-size: 1.5em;
}

/* line 359, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#photo1.active, #photo2.active, .placeholder.active {
  opacity: 1;
}

/* line 363, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
p#instructions {
  margin-top: 1em;
  font-size: 1.25em;
}

/* line 368, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
p#instructions strong {
  font-weight: 700;
}

/* line 370, /Users/207495/Dropbox/nyt/firehose/app/assets/stylesheets/teaserfirehose.css.scss.erb */
#teaser-container:not(.no-loader) header,
#teaser-container:not(.no-loader) #photo1,
#teaser-container:not(.no-loader) #photo2 {
  display: none;
}

</style>
<h1>This is a test</h1>
<div class="intrinsic-wrapper loaded open">
  <div id="firehose-container" class="firehose-container teaser open">
      <div id="loading">

      </div>

      <div id="closed">
          <div id="message">
              <h3>The Photo Firehose<br /> has been turned off.</h3>
              <hr />
              <p>Thanks for tuning in.<!--  The stream will return <br/> on Tuesday, July 8th at 11 a.m.<span id="countdown"></span> --></p>
          </div>
          <div id="staticbars">
              <hr class="largebar" />
              <hr class="smallbar" />
          </div>
      </div>

      <div id="open">
          <div class="photo-container">
              <!-- <div id="loader">
              </div> -->
              <div class="wc-firehose">
                  <div class='placeholder active' style='background-color: #e2e2e2;'></div>
                  <div id="photo1">
                   <a href="">
                      <div class="photo"></div></a>
                      <span class="credit"></span>
                  </div>
                  <div id="photo2">
                   <a href="">
                      <div class="photo"></div></a>
                      <span class="credit"></span>
                  </div>
              </div>
          </div>
      </div>
  </div>
</div>


<script>
document.domain = "nytimes.com";
var options = {
    imageHref: "",
    fadeTime: "",
    mode: "cycle",
    projectTitle: "olympics",
    relatedLink: "",
    introText: "fffsdfsdfjh",
    shareTitle: "olympics",
    shareText: "",
    consumerName: "olytv:ticker_tape",
    streamname: "firehose:olympics",
    initial_timeout: 0,
    broker: {
        load_url: "http://int.stg.nyt.com/data/ic/",
        websocket_on: true,
        polling_on: false
    }
}

// Set Project Specific HTML
// document.getElementById("project-title").textContent = options.projectTitle;
// document.getElementById("project-title").setAttribute("href", options.relatedLink);
// document.getElementById("intro-text").textContent = options.introText;
</script>
<script type="text/javascript">
    define('pourover', ['underscore/nyt'], function(_) {
  var PourOver = (function(){
    var ctor = function(){};

    var create = _.create || function(prototype){
      ctor.prototype = prototype;
      var result = new ctor;
      ctor.prototype = null;
      return result;
    };

    PourOver = {
      // Utility functions. Skip down to "Collections" for the real meat of PourOver.
      //
      // # The basic sorted set operations
      //
      union_sorted: function(a,b){
        // Make more efficient by just copying at Infinity
        var lowa = 0, lowb = 0, higha = a.length, highb = b.length, result=[], la, lb;
        while (higha > lowa || highb > lowb){
          la = a[lowa];
          lb = b[lowb];
          if(_.isUndefined(la)) la = Infinity;
          if(_.isUndefined(lb)) lb = Infinity;
          if(lowa == higha){
            return result.concat(b.slice(lowb,highb));
          }
          if(lowb == highb){
            return result.concat(a.slice(lowa,higha));
          }
          if(la == lb){
            result.push(la);
            lowa++;lowb++;
          } else if (la < lb){
            result.push(la);
            lowa++;
          } else {
            result.push(lb);
            lowb++;
          }
        }
        return result;
      },
      intersect_sorted: function(a,b){
        var lowa = 0, lowb = 0, higha = a.length, highb = b.length, result=[], la, lb;
        while (higha > lowa && highb > lowb){
          la = a[lowa];
          lb = b[lowb];


          if(la == lb){
            result.push(la);
            lowa++;lowb++;
          } else if (la < lb){
            lowa++;
          } else {
            lowb++;
          }
        }
        return result;
      },
      subtract_sorted: function(a,b){
        var lowa = 0, lowb = 0, higha = a.length, highb = b.length, result=[], la, lb;
        while (higha > lowa || highb > lowb){
          la = a[lowa];
          lb = b[lowb];
          if(higha == lowa){
            return result;
          }
          if(highb == lowb){
            return result.concat(a.slice(lowa,higha));
          }
          if(la == lb){
            lowa++;lowb++;
          } else if (la < lb){
            result.push(la);
            lowa++;
          } else {
            lowb++;
          }
        }
        return result;
      },
      insert_sorted: function(set,element){
        var length = set.length,
          i = 0,
          last_elem = set[length - 1];
        if(element > last_elem){
          set.push(element);
          return set;
        }
        while(i < length){
          if(element < set[i]){
            return set.slice(0,i).concat([element]).concat(set.slice(i,length));
          } else {
            i++;
          }
        }
        set.push(element);
        return set;
      },

      //
      // # Sort support
      //

      // Sort the set according to some function and then store an array of the translations
      // of the indicies. So if the first item went to index 2 after being sorted, put 2 in
      // the first spot of the permutation array.
      build_permutation_array: function(set,sort){
        var sorted_set = _.clone(set),perm=[];
        if(typeof(sort) === "function"){
          sorted_set.sort(sort);
        } else {
          sorted_set.sort(function(a,b){return sort.fn.call(sort,a,b);});
        }
        _.each(sorted_set,function(m,i){perm[m.cid] = i;});
        return perm;
      },
      // Use a permutation array to resort a subset of a collection.
      permute_from_array: function(collection,perm){
        var output = [];
        if(typeof(collection[0]) === "number"){
          _.each(collection,function(i){ output[perm[i]] = i ;});
        } else {
          _.each(collection,function(i){ output[perm[i.cid]] = i ;});
        }
        return _.without(output,undefined);
      },
      // Remove an element from a sorted set.
      remove_sorted: function(set,element){
        var length = set.length,
            i = 0;
        while(i < length){
          if(element == set[i]){
            return set.slice(0,i).concat(set.slice(i+1,length));
          } else {
            i++;
          }
        }
        return set;
      },
      bisect_by: function(f) {
        // Thanks to crossfilter (https://github.com/square/crossfilter) for this implementation.
        function bisectLeft(a, x, lo, hi) {
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (f(a[mid]) < x) lo = mid + 1;
            else hi = mid;
          }
          return lo;
        }

        function bisectRight(a, x, lo, hi) {
          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (x < f(a[mid])) hi = mid;
            else lo = mid + 1;
          }
          return lo;
        }

        bisectRight.right = bisectRight;
        bisectRight.left = bisectLeft;
        return bisectRight;
      },
      // # Pre-defined cache methods
      // Caching is really the raison d'etre of Pourover. Every filter has two cache methods: one for rebuilding the whole filter from scratch
      // and one for adding new items. As Pourover grows it will gain more pre-defined cache methods that correlate with common UI and data patterns.
      cacheMethods: {
        // ### Default: the dumb caches.
        // Just goes through each possible value for the filter and tests every item in the collection against it. As expensive as
        // possibile, but simple.
        defaultCache: function(items){
          var that = this;
          _.each(that.possibilities,function(p){
            var matching_items = _.filter(items,function(i){return that.fn(p,i);}),
                matching_cids = _.pluck(matching_items,'cid');
            p.matching_cids = matching_cids;
          });
        },
        defaultAddCache: function(items){
          var that = this;
          _.each(that.possibilities,function(p){
            var matching_items = _.filter(items,function(i){return that.fn(p,i);}),
                matching_cids = _.pluck(matching_items,'cid');
            p.matching_cids = PourOver.union_sorted(p.matching_cids,matching_cids);
          });
        },
        // ### Exact: the fastest caches.
        // For filters that evaluate by strict equality (this property === this value). The name of the filter must
        // match the name of the property for exact cache to work.
        exactCache: function(items){
          var that = this,
              attr = this.attr || this.name;
          _.each(items,function(i){
            var p = that.possibilities[i[attr]];
            if (p) {
              p.matching_cids = PourOver.insert_sorted(p.matching_cids,i.cid);
            }
          });
        },
        exactAddCache: function(items){
          PourOver.cacheMethods.exactCache.call(this,items);
        },
        inclusionCache: function(items){
          var that = this,
              attr = this.attr || this.name;
          _.each(items,function(i){
            _.each(i[attr],function(v){
              var p = that.possibilities[v];
              if(p){
                p.matching_cids = PourOver.insert_sorted(p.matching_cids,i.cid);
              }
            });
          });
        },
        inclusionAddCache: function(items){
          PourOver.cacheMethods.inclusionCache.call(this,items);
        }
      }
    };
        // Copied from Backbone
        var array = [];
        var push = array.push;
        var slice = array.slice;
        var splice = array.splice;
        var Events = PourOver.Events = {

        // Bind an event to a `callback` function. Passing `"all"` will bind
        // the callback to all events fired.
        on: function(name, callback, context) {
          if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
          this._events || (this._events = {});
          var events = this._events[name] || (this._events[name] = []);
          events.push({callback: callback, context: context, ctx: context || this});
          return this;
        },

        // Bind an event to only be triggered a single time. After the first time
        // the callback is invoked, it will be removed.
        once: function(name, callback, context) {
          if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
          var self = this;
          var once = _.once(function() {
            self.off(name, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
          return this.on(name, once, context);
        },

        // Remove one or many callbacks. If `context` is null, removes all
        // callbacks with that function. If `callback` is null, removes all
        // callbacks for the event. If `name` is null, removes all bound
        // callbacks for all events.
        off: function(name, callback, context) {
          var retain, ev, events, names, i, l, j, k;
          if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
          if (!name && !callback && !context) {
            this._events = void 0;
            return this;
          }
          names = name ? [name] : _.keys(this._events);
          for (i = 0, l = names.length; i < l; i++) {
            name = names[i];
            if (events = this._events[name]) {
              this._events[name] = retain = [];
              if (callback || context) {
                for (j = 0, k = events.length; j < k; j++) {
                  ev = events[j];
                  if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                      (context && context !== ev.context)) {
                    retain.push(ev);
                  }
                }
              }
              if (!retain.length) delete this._events[name];
            }
          }

          return this;
        },

        // Trigger one or many events, firing all bound callbacks. Callbacks are
        // passed the same arguments as `trigger` is, apart from the event name
        // (unless you're listening on `"all"`, which will cause your callback to
        // receive the true name of the event as the first argument).
        trigger: function(name) {
          if (!this._events) return this;
          var args = slice.call(arguments, 1);
          if (!eventsApi(this, 'trigger', name, args)) return this;
          var events = this._events[name];
          var allEvents = this._events.all;
          if (events) triggerEvents(events, args);
          if (allEvents) triggerEvents(allEvents, arguments);
          return this;
        },

        // Tell this object to stop listening to either specific events ... or
        // to every object it's currently listening to.
        stopListening: function(obj, name, callback) {
          var listeningTo = this._listeningTo;
          if (!listeningTo) return this;
          var remove = !name && !callback;
          if (!callback && typeof name === 'object') callback = this;
          if (obj) (listeningTo = {})[obj._listenId] = obj;
          for (var id in listeningTo) {
            obj = listeningTo[id];
            obj.off(name, callback, this);
            if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
          }
          return this;
        }

      };

      // Regular expression used to split event strings.
      var eventSplitter = /\s+/;

      // Implement fancy features of the Events API such as multiple event
      // names `"change blur"` and jQuery-style event maps `{change: action}`
      // in terms of the existing API.
      var eventsApi = function(obj, action, name, rest) {
        if (!name) return true;

        // Handle event maps.
        if (typeof name === 'object') {
          for (var key in name) {
            obj[action].apply(obj, [key, name[key]].concat(rest));
          }
          return false;
        }

        // Handle space separated event names.
        if (eventSplitter.test(name)) {
          var names = name.split(eventSplitter);
          for (var i = 0, l = names.length; i < l; i++) {
            obj[action].apply(obj, [names[i]].concat(rest));
          }
          return false;
        }

        return true;
      };

      // A difficult-to-believe, but optimized internal dispatch function for
      // triggering events. Tries to keep the usual cases speedy (most internal
      // PourOver events have 3 arguments).
      var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
          case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
          case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
          case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
          case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
          default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
        }
      };

      var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

      // Inversion-of-control versions of `on` and `once`. Tell *this* object to
      // listen to an event in another object ... keeping track of what it's
      // listening to.
      _.each(listenMethods,function(implementation, method) {
        Events[method] = function(obj, name, callback) {
          var listeningTo = this._listeningTo || (this._listeningTo = {});
          var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
          listeningTo[id] = obj;
          if (!callback && typeof name === 'object') callback = this;
          obj[implementation](name, callback, this);
          return this;
        };
      });

      // Aliases for backwards compatibility.
      Events.bind   = Events.on;
      Events.unbind = Events.off;

      // Allow the `PourOver` object to serve as a global event bus, for folks who
      // want global "pubsub" in a convenient place.
      _.extend(PourOver, Events);
      // #Collections
      //The main kind of object in Pourover. A collection is basically a wrapper around an array of objects.
      //It adds collection ids to its members and has support for various ways of retrieving all or a part of
      //its members.

      PourOver.Collection = function(items,opts){
        if(typeof(items) == "undefined"){items = [];}
        this.items = [];
        this.filters = {};
        this.sorts = {};
        this.addItems(items);
        this.on("change",function(){
          _.each(this.filters,function(f){ if(f.current_query){f.current_query.refresh();} });
          _.each(this.sorts, function(s){ s.rebuild_sort(true);  });
        });
        this.initialize.apply(this, arguments);
      };

      _.extend(PourOver.Collection.prototype,PourOver.Events,{
          initialize: function(){},
          // Force the filters and sorts of a collection to refresh. Generally most useful if you have batched
          // up a bunch of silented actions and you want to refresh once at the end.
          refresh: function(){
            this.trigger("queryChange");
          },

          // Retrive the objects associated with an array of cids. Like everything in Pourover, the cids must be sorted.
          // This is not ususally an issue as you generally will not be calling `collection.get` with an array you
          // manually create. You will probably be using the output of some function that keeps it sorted for you.
          get: function(cids){
            return PourOver.Collection.prototype.getBy.call(this,"cid",cids,true);
          },

          // Similar to get, except -- rather than getting items by cid -- you are getting them by [attr_name].
          // Here vals is an array of [attr_names]s.
          getBy: function(attr_name,vals,sorted){
            if(! _.isArray(vals)){ var vals = [vals] }
            if(typeof(sorted) == "undefined"){sorted = false;}
            var low = 0, high = this.items.length,lc = 0, hc = vals.length, output = [],items = this.items,i;
            if(sorted == true){
              while (low < high && lc < hc){
                if (vals[lc] == (i=items[low])[attr_name]){
                  output.push(i);
                  low++;
                  lc++;
                } else if (vals[lc] < i[attr_name]){
                  lc++;
                } else{
                  low++;
                }
              }
            } else if (sorted == "reverse"){
              while (low < high && lc < hc){
                if (vals[lc] == (i=items[low])[attr_name]){
                  output.push(i);
                  low++;
                  lc++;
                } else if (vals[lc] > i[attr_name]){
                  lc++;
                } else{
                  low++;
                }
              }
            } else {
              while (low < high && lc < hc){
                if ( _.include(vals, (i=items[low])[attr_name])){
                  output.push(i);
                  vals = _.without(vals, i[attr_name]);
                  low++;
                  lc++;
                } else {
                  low++;
                }
              }
            }
            return output;
          },
          getByFirst: function(attr_name,val,sorted){
            if(typeof(sorted) == "undefined"){sorted = false;}
            var low = 0, high = this.items.length, output = undefined,items = this.items,i;
            if(sorted == true){
              while (low < high){
                if (val == (i=items[low])[attr_name]){
                  output = i;
                  break;
                } else if (val < i[attr_name]){
                  break;
                } else{
                  low++;
                }
              }
            } else if (sorted == "reverse"){
              while (low < high){
                if (val == (i=items[low])[attr_name]){
                  output = i;
                  break;
                } else if (val > i[attr_name]){
                  break;
                } else{
                  low++;
                }
              }
            } else {
              while (low < high){
                if (val == (i=items[low])[attr_name]){
                  output = i;
                  break;
                } else {
                  low++;
                }
              }
            }
            return output;
          },

          // Add items to the collection, triggering the appropriate events to keep all dependent sort and filter sets up-to-date.
          addItems: function(i){
            this.trigger("will_change");
            if(! _.isArray(i)){ i = [i] }
            var last_id = this.items.length > 0 ? _.last(this.items).cid + 1 : 0,new_items;
            new_items = _.map(i,function(c){var n = PourOver.Item(c); n.cid = last_id++; return n;});
            this.items = this.items.concat(new_items);
            this.regenerateFilterSets(new_items);
            this.trigger("change",_(new_items).pluck("cid"));
          },

          // Remove items from the collection, triggering the appropriate events to keep all dependent sort and filter sets up-to-date.
          // This functionality is only included begrudgingly. Pourover is best for collections that rarely remove members.
          // TODO: Optimize
          removeItems: function(i,isSorted){
            this.trigger("will_change");
            if(typeof(isSorted) === "undefined"){var isSorted = false}
            if(! _.isArray(i)){ var i = [i] }
            if(isSorted){
              i = i.sort(function(a,b){return a.cid - b.cid ;});
              var new_items = [],old_items = this.items,new_length = i.length,old_length = this.items.length,newi = 0, oldi = 0;
              while(oldi < old_length){
                if(! newi < new_length){
                  new_items = new_items.concat(old_items.slice(oldi));
                  break;
                } else if(old_items[oldi].cid === i[newi].cid){
                  newi++;
                  oldi++;
                } else {
                  new_items.push(old_items[oldi]);
                  oldi++;
                }
              }
            } else {
              var new_items = [], old_items = this.items,old_length = this.items.length, oldi = 0,delete_cids = _.pluck(i,"cid");
              while(oldi < old_length && delete_cids.length > 0){
                if(_.include(delete_cids, old_items[oldi].cid)){

                } else {
                  new_items.push(old_items[oldi]);
                }
                oldi++;
              }
            }
            this.items = new_items;
            this.regenerateFilterSets();
            this.trigger("change",_(i).pluck("cid"));
          },

          // # Collection filter functions
          // All filters are associated to collections rather than views. This allows for multiple views to share the same filter.
          // This is especially useful for modal situations in which you can set filters on a grid view that are reflected in the
          // one up view as well.
          addFilters: function(f){
            var that = this,new_filters;
            if(! _.isArray(f)){ f = [f] }
            new_filters = _.reduce(f,function(m,i){ m[i.name] = create(i); m[i.name].collection = that; return m; },{});
            this.filters = _.extend(this.filters,new_filters);
            // Bubble all query change events up from the individual filters to the collection. This allows a developers to
            // specify events that should be triggered whenever any filter's query is changed.
            _.each(new_filters,function(f){
              f.on("queryChange",function(){
                that.trigger("queryChange");
              });
              // All filters precache the result of their filtering. This is the source of pourover's speed optimizations.
              f.cacheResults(that.items);
              // If a user passes in an `associated_attrs` property on a filter, that filter will re-cache its result whenever
              // any object in the collection has an attribute changed. Setting `associated_attrs` is essential for admins or
              // other uses in which filterable values can change.
              if(f.associated_attrs){
                _.each(f.associated_attrs,function(a){
                  that.on("change:"+a,function(objs){
                    f.removeFromCache(objs);
                    f.addCacheResults(objs);
                    if(f.current_query){f.current_query.refresh();}
                  });
                });
              }
            });
          },

          // A shortcut to re-calculate the results of every filter. This is expensive if you do not pass in `new_items`, in which cases
          // only the new_items will be cached and the filters updated.
          regenerateFilterSets: function(new_items){
            var that = this;
            // If no new items are passed in, regenerate filters for all items in the collection
            if(typeof(new_items) == "undefined"){
              _.each(this.filters,function(f){
                f.cacheResults(that.items);
              });
            } else {
              _.each(this.filters,function(f){
                f.addCacheResults(new_items);
              });
            }
          },

          // A shortcut for returning a match object containing all the items in a collection. More on matches below.
          getAllItems: function(){
            var cids = _.pluck(this.items,"cid");
            return new PourOver.MatchSet(cids,this,["all"]);
          },

          // Get the currently cached results for the last stateful query on a filter (the last time a `setQuery` was called on that filter.)
          // If `empty_default` is set to true, the function will return no items if the filter does not have a current query set. Otherwise,
          // the function will return all items in the collection. The former `empty_default` setting is useful when OR-ing filters together, when
          // you want an unset filter to represent an unselected dimension. The latter is useful when AND-ing filters together, when you
          // want an unset filter to comprise all objects in the collection.
          getCurrentFilteredItems: function(filter_name,empty_default){
            if(typeof(empty_default) === "undefined"){empty_default = false;}
            if(this.filters[filter_name].current_query && this.filters[filter_name].current_query.stack.length > 0){
              return this.filters[filter_name].current_query;
            } else {
              if(empty_default){
                return new PourOver.MatchSet([],this,[]);
              } else {
                return this.getAllItems();
              }
            }
          },

          // The non-stateful way to query a filter. Simply returns the result of the query but does not store the query on the filter.
          getFilteredItems: function(filter_name,query){
            var filter = this.filters[filter_name],possibility;
            if (_.isUndefined(filter) ) throw "The filter " + filter_name + " does not exist.";
            return filter.getFn(query);
          },

          // # Sort functions
          // Sorts, like filters, are generally stored on collections for the same reason that filters are stored on the collection rather than the view.
          // However, whereas filters keep track of their own state and this is shared between views, the state of which sort is enabled is stored on the view.

          addSort: function(sort){
            var that = this;
            this.sorts[sort.name] = sort;
            sort.collection = this;
            sort.rebuild_sort();
            // Like filters, if you set `associated_attrs` on a sort, they will rebuild themselves whenever any item in the collection undergoes a change
            // on that attribute.
            // TODO: Consider cloning on add. Also, bring in line with addFilter (events or not!?)
            if(sort.associated_attrs){
              _.each(sort.associated_attrs,function(a){
                that.on("change:"+a,function(objs){
                  sort.rebuild_sort();
                });
              });
            }
          },

          // Add multiple sorts.
          addSorts: function(sorts){
            if(typeof(opts) === "undefined"){ opts = {};}
            if(! _.isArray(sorts)){sorts = [sorts];}
            var that = this;
            _.each(sorts,function(s){
              that.addSort(s);
            });
          },

          // The non-stateful way to retrieve all the items in the collection, sorted.
          getSortedItems: function(sort_name){
            var s = this.sorts[sort_name],that = this,output;
            return s.sort(this.items);
          },

          // A silly shortcut, pass in a cid and an attribute, retrieve its value. Useful for template helpers.
          getItemValue: function(cid,attribute){
            var item = _.find(this.items,function(i){return i.cid === Number(cid);});
            return item[attribute];
          },

          // Update the value of one attribute of one item in the collection.
          updateItem: function(cid,attribute,value){
            this.trigger("will_incremental_change");
            var item = _.find(this.items,function(i){return i.cid === Number(cid);});
            item[attribute] = value;
            this.trigger("change:"+attribute,[item]);
            this.trigger("incremental_change",[attribute]);
            this.trigger("update","updateItem");
            return item.guid;
          },

          // Delete an attribute of one item in the collection.
          removeItemAttribute: function(cid,attribute,value){
            this.trigger("will_incremental_change");
            var item = _.find(this.items,function(i){return i.cid === Number(cid);});
            delete item[attribute];
            this.trigger("change:"+attribute,[item]);
            this.trigger("incremental_change",[attribute]);
            this.trigger("update","updateItem");
            return item.guid;
          },

          // Change the value of one attribute of many items to the same value.
          batchUpdateItems: function(cids,attribute,value){
            this.trigger("will_incremental_change");
            var items = this.get(cids,true);
            _.each(items,function(i){
              i[attribute] = value;
            });
            this.trigger("change:"+attribute,items);
            this.trigger("incremental_change",[attribute]);
            this.trigger("update","batchUpdate");
            return _.pluck(items,"guid");
          },

          // Change the value of several attributes of a single item in the collection.
          updateAttributes: function(cid,updates,silent){
            if(typeof(silent) === "undefined"){var silent = false;}
            this.trigger("will_incremental_change");
            var item = _.find(this.items,function(i){return i.cid === Number(cid);});
            var that = this;
            _.each(updates,function(v,k){
              item[k] = v;
              that.trigger("change:"+k,[item]);
            });
            this.trigger("incremental_change",_.keys(updates));
            if(!silent) {
              this.trigger("update","updateAttribute");
            }
            return item.guid;
          },

          // Change the value of several attributes of several items in the collection. Here 'updates'
          // is a hash of attributes -> new values.
          batchUpdateAttributes: function(cids,updates,silent){
            if(typeof(silent) === "undefined"){var silent = false;}
            this.trigger("will_incremental_change");
            var items = this.get(cids,true);
            var that = this;
            _.each(items,function(item){
              _.each(updates,function(v,k){
                item[k] = v;
              });
            });
            _.each(updates,function(v,k){
              that.trigger("change:"+k,items);
            });
            this.trigger("incremental_change",_.keys(updates));
            if (!silent) {
              this.trigger("update","batchUpdate");
              this.trigger("batchUpdateAttribute");
            }
            return _.pluck(items,"guid");
          },

          batchLoadItems: function(data){
            this.trigger("will_incremental_change");
            var new_cids = [],
                guids = _.pluck(data, "guid"),
                old_items = this.getBy("guid", guids),
                old_item_dict = {};

            _(old_items).each(function (item) { old_item_dict[item.guid] = item; });

            _.each(data,_.bind(function(d){
                var item = old_item_dict[d.guid],
                    last_id = this.items.length > 0 ? _(this.items).last().cid + 1 : 0,
                    current_item;
                if (item){
                  current_item = item;

                  // update the item's attrs
                  _.each(d, function(v,k){
                    current_item[k] = v;
                  });
                } else {
                    item = PourOver.Item(d);
                    item.cid = last_id++;
                    new_cids.push(item.cid);
                    this.items = this.items.concat([item]);

                    // add this to the list of existing items so that
                    // if data contains the same guid multiple times,
                    // the second instance will be treated as an update.
                    old_items[item.guid] = item;
                }
            },this))

            this.regenerateFilterSets();
            this.trigger("incremental_change","*");
            this.trigger("change",new_cids);
            this.trigger("update","batchLoad");
            this.trigger("batchLoadItems");
          }
      });

      // #Items
      // If we ever need to add properties to items in a collection, the code would go here.
      PourOver.Item = function(i){
        return i;
      },

      // #Filters

      // A filter is basically a rule for mapping items of a collection into groups based on attribute
      // values. It caches the results and can be queried either statefully or non-statefully, depending
      // on developer preference.
      PourOver.Filter = function(name,values,opts){
        if(typeof(opts) === "undefined"){opts = {};}
        this.name = name;
        this.possibilities = this.create_possibilities(values);
        this.values = _.pluck(values,"value");
        _.extend(this,opts);
        this.initialize.apply(this, arguments);
      }

      _.extend(PourOver.Filter.prototype,PourOver.Events,{

        // Initialize is a no-op by default.
        initialize: function(){},

        // Given an array of possible values, initializes the object that will store the cached results
        // of querying for that possibility.
        create_possibilities: function(vs){
          var o = {};
          _.each(vs,function(v){
            var name = v.name || String(v.value);
            o[name] = v;
            o[name].matching_cids = [];
          });
          return o;
         },

         // cacheResults and addCacheResults are generic methods that are must be overridden before instantiating a filter.
         // The preset filters included below provide good examples of how these functions should be written. cacheResults
         // should cache all the items in the collection, whereas addCacheResults incrementally adds new items to already
         // cached, filtered results.
         cacheResults: function(items){
           throw "No cache function has been defined for this filter '" + this.name + "'.";
         },
         addCacheResults: function(items){
           throw "No add cache function has been defined for this filter '" + this.name + "'.";
         },

         makeQueryMatchSet: function(cids,query){
            return new PourOver.MatchSet(cids, this.getCollection(), [[this,query]]);
         },

         // Generally only used when removing items from a collection or when an item changes value. This will remove the item from
         // the cache so that it can either be recached with its new value or thrown away.
         removeFromCache: function(items){
          var cids = _.pluck(items,"cid").sort(function(a,b){return a-b;});
          _.each(this.possibilities,function(p){
            p.matching_cids = PourOver.subtract_sorted(p.matching_cids,cids);
          });
         },

         // The stateful way to query a filter. Delegates the retrieval of a MatchSet to the filter's getFn and caches the results on the filter.
         query: function(q,silent){
           if(typeof(silent) === "undefined"){var silent = false;}
           var match_set = this.getFn(q);
           this.setQuery(match_set,silent);
         },

         // Assigns a MatchSet to a filter (caches the result) and triggers the appropriate events.
         setQuery: function(q,silent){
           if(typeof(silent) === "undefined"){var silent = false;}
           this.current_query = q;
           if(!silent){
             this.trigger("queryChange");
           }
         },

         // Removes a cached result from a filter.
         clearQuery: function(silent){
           if(typeof(silent) === "undefined"){var silent = false;}
           this.current_query = false;
           if(!silent){
             this.trigger("queryChange");
           }
         },

         // Unions a cached result with another result (both being MatchSets) and produces a new MatchSet.
         unionQuery: function(q,silent){
           if(typeof(silent) === "undefined"){var silent = false;}
           if(typeof(q) === "string" || typeof(q) === "number" || _.isArray(q)){
             var q = this.getFn(q);
           }
           if(this.current_query){
             this.current_query = this.current_query.or(q);
           } else {
             this.current_query = q;
           }
           if(!silent){
             this.trigger("queryChange");
           }
         },

         // Intersects a cached result with another result (both being MatchSets) and produces a new MatchSet.
         intersectQuery: function(q,silent){
           if(typeof(silent) === "undefined"){var silent = false;}
           if(typeof(q) === "string" || typeof(q) === "number" || _.isArray(q)){
             var q = this.getFn(q);
           }
           if(this.current_query){
             this.current_query = this.current_query.and(q);
           } else {
             this.current_query = q;
           }
           if(!silent){
             this.trigger("queryChange");
           }
         },

         // Subtracts a cached result with another result (both being MatchSets) and produces a new MatchSet.
         subtractQuery: function(q,silent){
           if(typeof(silent) === "undefined"){var silent = false;}
           if(typeof(q) === "string" || typeof(q) === "number" || _.isArray(q)){
             var q = this.getFn(q);
           }
           if(this.current_query){
             this.current_query = this.current_query.not(q);
           } else {
             this.current_query = q;
           }
           if(!silent){
             this.trigger("queryChange");
           }
         },

         // This is the inverse of the three functions above. Removes a query from a compound, cached MatchSet on a filter.
         // This is useful when you have a UI in which subsequent selections union together. It is faster on a toggle to remove
         // the deselected possibility rather than re-union the remaining selected ones.
         // TODO: Test
         removeSingleQuery: function(q,silent){
           if(! this.current_query){return false;}
           if(typeof(silent) === "undefined"){var silent = false;}
           if(typeof(q) === "string" || typeof(q) === "number" || _.isArray(q)){
             var q = this.getFn(q);
           }
           var s = [],
               stack = this.current_query.stack,new_stack,
               is_compound = function(c){return _.isString(c) && c.match(/^(or|and|not)$/);};
            new_stack = _.reduce(stack,function(m,i){
              if(i[1] === q.stack[0][1]){
                return m;
              } else if(is_compound(i[0]) && i[1][0][1] === q.stack[0][1]){
                return m;
              } else {m.push(i); return m;}
            },s);
           if(new_stack[0] && (new_stack[0][0] == "and" || new_stack[0][0] == "or" || new_stack[0][0] == "not")){
             new_stack[0] = new_stack [0][1][0];
           }
           this.current_query.stack = new_stack;
           this.current_query.refresh();
           if(!silent){
             this.trigger("queryChange");
           }
         },

         // Convenice method for getting the collection attached to a filter.
         // Just an aesthetic thing. I like the explicit "getCollection" calls in
         // the rest of the code.
         getCollection: function(){
           return this.collection;
          },

         getByPossibilityGroups: function(){
           var collection = this.collection;
           return _.reduce(this.possibilities,function(m,p,k){m[k] = collection.get(p.matching_cids); return m;},{});
         }
      });

      // #Sorts
      //
      // Sorts cache different orderings of collection items and subsets thereof. Sorts generally belong to collections,
      // but they can belong to views as well for optimization concerns.
      PourOver.Sort = function(name,opts){
        this.name = name;
        _.extend(this,opts);
        this.initialize.apply(this, arguments);
      };

      _.extend(PourOver.Sort.prototype,PourOver.Events,{
        initialize: function(){},

        // By default, sorts are not view sorts. A view sort is attached to a specific view and only updates when that
        // view undergoes a queryChange.
        view: false,

        // Use a sort to order an array of cids
        sort: function(set){return PourOver.permute_from_array(set,this.permutation_array);},

        // Recache the results of sorting the collection.
        rebuild_sort: function(new_items){
          if(typeof(new_items) === "undefined") {new_items = false;}
          if(this.view){
            var items = this.view.match_set.all();
          } else {
            var items = this.collection.items;
          }
          this.permutation_array = PourOver.build_permutation_array(items,this);
          this.trigger("resort", new_items);
        }
      });

      // #Views
      //
      // Views store a state of collection and are generally what should be rendered. There can be many views per collection.
      // Views can be paged. Moreover, a view has a selection function which tells the view how to compose its various filters to produce the current set.
      PourOver.View = function(name,collection,opts){
        var that = this;
        this.name = name;
        if(typeof(opts) === "undefined"){ opts = {};}
        this.collection = collection;
        this.match_set = new PourOver.MatchSet(_.pluck(this.collection.items,"cid"),this.collection,["all"]);
        if(opts.template){this.template = opts.template;}

        // Whenever the collection gains or loses members, recache the MatchSet saved on the view.
        this.collection.on("will_change will_incremental_change",function(){
            that.storeViewPosition();
        });

        this.collection.on("change",function(){
          that.match_set.refresh();
          that.setNaturalSelection();
          that.resetPage();
          that.trigger("collection-change");
        });

        // Whenever an item in the collection is changed, recache the MatchSet saved on the view.
        this.collection.on("incremental_change",function(attrs){
          that.match_set.refresh();
          that.setNaturalSelection(attrs);
          that.resetPage();
          that.trigger("collection-incremental-change");
        });

        // Bubble all collection update events through.
        this.collection.on("update",function(f){
          that.trigger("update",f);
        });

        // Whenever any filter is queried statefully, reset the view's MatchSet; We don't have to refresh the match_set here. That is only necessary
        // when it's possible that a filter has stale information as a result of a change in the underlying data.
        this.collection.on("queryChange",function(){
          that.setNaturalSelection();
          that.trigger("update","query");
        });

        // Bubble up sortChange events as updates
        this.on("sortChange",function(){
          this.trigger("update","sort");
        });

        // Bubble up pageChange events as updates
        this.on("pageChange",function(){
          this.trigger("update","page");
        });
        this.view_sorts = [];
        _.extend(this,opts);
        this.initialize.apply(this, arguments);
      };

      _.extend(PourOver.View.prototype,PourOver.Events,{
        initialize: function(){},
        current_page: 0,

        // By default, return all items in the view.
        page_size: Infinity,
        current_sort: false,

        // Changes a view from being sorted to no longer being sorted.
        removeSort: function(){
          if(this.current_sort.off){this.current_sort.off("resort");}
          this.current_sort = false;
          this.trigger("sortChange");
        },

        // Sets a sort on a view and fires all appropriate events.
        setSort: function(sort_name,view_sort,silent){
          if(typeof(view_sort) === "undefined"){view_sort = false;}
          if(typeof(silent) === "undefined"){silent = false;}
          var that = this;
          if(this.current_sort.off){this.current_sort.off("resort");}
          if(sort_name && view_sort){
            this.current_sort = this.view_sorts[sort_name];
            this.current_sort.on("resort",_.bind(function(new_items){
              if (!(this.silent_sort && new_items)) {
                that.trigger("sortChange");
              }
            },this));
          } else if(sort_name){
            this.current_sort = this.collection.sorts[sort_name];
            this.current_sort.on("resort",_.bind(function(new_items){
              if (!(this.silent_sort && new_items)) {
                that.trigger("sortChange");
              }
            },this));
          } else {
            this.current_sort = false;

          }
          if(! silent){
            this.trigger("sortChange");
          }
        },

        // Return the name of the current sort of the view.
        getSort: function(){
          if (!this.current_sort){
            return false;
          } else {
            return this.current_sort.name;
          }
        },

        // Add a sort to the view. The difference between this and a collection sort is that this sort will
        // only change if the view receives a selectionChange.
        addViewSorts: function(sorts){
            if(typeof(opts) === "undefined"){ opts = {};}
            if(! _.isArray(sorts)){sorts = [sorts];}
            var that = this;
            _.each(sorts,function(sort){
              that.view_sorts[sort.name] = sort;
              sort.collection = that.collection;
              sort.view = that;
              sort.rebuild_sort();
              that.on("selectionChange",function(attrs){
                if(sort.associated_attrs == undefined || attrs === "*"){
                  sort.rebuild_sort();
                }
                if(sort.associated_attrs && _.intersection(sort.associated_attrs,attrs).length > 0){
                  sort.rebuild_sort();
                }
              });
            });
        },

        // IMPORTANT: This determines how a view composes the filters on a collection to generate results. Here, by default,
        // every filter on the collection is intersected. This is often the desired behavior. However, this must be overridden
        // if you want your view to do fancier things such as union some filters, difference others, and intersect the rest.
        selectionFn: function(){
          var collection = this.collection;
          if(_.isEmpty(collection.filters)){
            return collection.getAllItems();
          }
          var output = _.reduce(collection.filters,function(m,i){
            var q = i.current_query;
            if(m && (!q || _.isEmpty(q.stack))){ return m;}
            if(!m && (!q || _.isEmpty(q.stack))){return collection.getAllItems();}

            if(m){
              return m.and(q);
            } else {
              return q;
            }
          },false);
          return output;
        },

        // Caches a MatchSet on the view as the current match_set;
        setSelection: function(match_set,attrs){
          this.match_set = match_set;
          this.trigger("selectionChange",attrs);
        },

        // Delegates to the views selectionFn to generate an array of valid cids given the current filters.
        setNaturalSelection: function(attrs){
          var selection;
          selection = this.selectionFn();
          this.setSelection(selection,attrs);
        },

        // Removes a MatchSet from a view and replaces it with the universe of possible items.
        clearSelection: function(){this.match_set = this.collection.getAllItems();},

        // IMPORTANT: This is the function you will call most often on views. This returns the cached, filtered items and
        // then sorts them and pages them as appropriate.
        getCurrentItems: function(page){
          if(! this.match_set){return [];}
          if(typeof(page) === "undefined"){
            var page = this.current_page;
          }
          if(this.page_size == Infinity){
            if(this.current_sort){
              var items = this.match_set.all_sorted(this.current_sort);
            } else {
              var items = this.match_set.all();
            }
          } else {
          // TODO: Slice cids before reassociating
            if(this.current_sort){
              var items = this.match_set.all_sorted_cids(this.current_sort);
              items = items.slice(this.page_size * page,this.page_size * (page + 1));
              var ordered_cids = _.clone(items).sort(function(a,b){return a-b;});
              var unsorted_items = this.collection.get(ordered_cids);
              items = _.map(items,function(i){return _.findWhere(unsorted_items,{cid:i});});
            } else {
              var items = this.match_set.cids;
              items = items.slice(this.page_size * page,this.page_size * (page + 1));
              items = this.collection.get(items);
            }
          }
          return items;
        },

        storeViewPosition: function(){
            var head_item =  this.getCurrentItems()[0];
            if(head_item){
                this.last_head_cid = head_item.cid;
            }
        },

        resetPage: function(){
            if(this.last_head_cid){
                if(this.current_sort){
                    this.current_sort.rebuild_sort();
                }
                this.pageTo(this.last_head_cid,true);
            }
            this.last_head_cid = undefined;
        },

        // Change the page of the view by [dir] pages. Negative values to page back.
        page: function(dir){
          var new_dir = dir + this.current_page;
          if(new_dir < 0) new_dir = 0;
          if(new_dir > Math.ceil(this.match_set.length()/this.page_size - 1)) new_dir = Math.ceil(this.match_set.length()/this.page_size - 1);
          this.current_page = new_dir;
          this.trigger("pageChange");
        },

        // Page to a specific cid.
        pageTo: function(cid,silent){
          if(typeof(silent) == "undefined"){
            var silent = false;
          }
          if(this.current_sort){
            var index = _.indexOf(this.match_set.all_sorted_cids(this.current_sort),cid),
                len = this.match_set.cids.length,
                page = Math.floor(index/this.page_size);
          } else {
            var index = _.indexOf(this.match_set.cids,cid),
                len = this.match_set.cids.length,
                page = Math.floor(index/this.page_size);
          }
          if(index >= 0){
              this.current_page = page;
              if(! silent){
                this.trigger("pageChange");
              }
          }
        },

        // Change the page of the view to a specific page.
        setPage: function(page) {
          if(page < 0) page = 0;
          if(page > Math.ceil(this.match_set.length()/this.page_size - 1)) page = Math.ceil(this.match_set.length()/this.page_size - 1);
          this.current_page = page;
          this.trigger("pageChange");
        },

        // Set the page size.
        setPageSize: function(size){
          this.page_size = size;
          this.trigger("pageChange");
        },
        render: function(){}
      });

      // #MatchSets
      //
      // These are what are returned from queries on filters. They can be chained together with ands, or, & nots.
      // They also keep a "stack" to remember how they were created (after chaining) so that they can refresh themselves.
      PourOver.MatchSet = function(cids,collection,stack){
        this.cids = cids;
        this.collection = collection;
        this.stack = stack;
        this.initialize.apply(this, arguments);
      };
      _.extend(PourOver.MatchSet.prototype,PourOver.Events,{
        initialize: function(){},

        // When the underlying data has changed re-evaluate which items are included in this possibily compound result.
        refresh: function(s,match_set){
         if(typeof(s) === "undefined"){var s = this.stack || []}
         if(s.length < 1 && match_set){
           this.cids = match_set.cids;
           return this;
         } else if (s.length < 1){
           this.cids = false;
           return this;
         }

         var step = s[0],
             operation = step[0],
             is_compound = function(c){return _.isString(c) && c.match(/^(or|and|not)$/);};
         if(typeof(operation) === "object"){
           match_set = operation.getFn(step[1]);
           return this.refresh(_.rest(s),match_set);
         } else if(operation === "all" || step === "all") {
           var cids = _.pluck(this.collection.items,"cid");
           match_set = new PourOver.MatchSet(cids,this,["all"]);
           return this.refresh(_.rest(s),match_set)
         } else if(is_compound(operation)) {
             var m = match_set[operation](this.refresh(step[1]));
         } else {
             var m = this.refresh(step[1]);
         }
         return this.refresh(_.rest(s),m);
        },

        // Intersect this MatchSet with another MatchSet.
        and: function(other_matches){
          if(this.stack.length < 1 && other_matches){
            return other_matches;
          } else if (!other_matches){
            return this;
          } else {
            var set = PourOver.intersect_sorted(this.cids,other_matches.cids);
            return new PourOver.MatchSet(set,this.collection,this.stack.concat([["and",other_matches.stack]]))
          }
        },

        // Union this MatchSet with another MatchSet.
        or: function(other_matches){
          if(this.stack.length < 1 && other_matches){
            return other_matches;
          } else if (!other_matches){
            return this;
          } else {
            var set = PourOver.union_sorted(this.cids,other_matches.cids);
            return new PourOver.MatchSet(set,this.collection,this.stack.concat([["or",other_matches.stack]]));
          }
        },

        // Difference this MatchSet with another MatchSet.
        not: function(other_matches){
          if(this.stack.length < 1 || ! other_matches){
            return this;
          } else {
            var set = PourOver.subtract_sorted(this.cids,other_matches.cids);
            return new PourOver.MatchSet(set,this.collection,this.stack.concat([["not",other_matches.stack]]));
          }
        },

        // Return all the items corresponding to the cids cached on the MatchSet.
        all: function(){ return this.collection.get(this.cids);},

        // Return a slice of the items corresponding to the cids cached on the MatchSet.
        slice: function(s,e){ return this.collection.get(this.cids.slice(s,e)) },

        // Return all the items corresponding to the cids cached on the MatchSet AND sorted by sort s.
        all_sorted: function(s){
          var c = this.all();
          if(s){
            return s.sort(c);
          } else {
            return c;
          }
        },

        // Sort the cached cids.
        all_sorted_cids: function(s){
          var c = this.cids;
          if(s){
            return s.sort(c);
          } else {
            return c;
          }
        },

        // Return how many items comprise this MatchSet.
        length: function(){return this.cids.length}
      });


    // #PourOver.UI
    // PourOver.UI is a simple add-on for creating objects to be rendered as UI elements controlling the
    // state of filters and views.
    PourOver.UI = {}
    PourOver.UI.Element = function(opts){
        if(typeof(opts) === "undefined"){var opts = {}}
        _.extend(this,opts)
        this.initialize.apply(this, arguments);
    }

    _.extend(PourOver.UI.Element.prototype,PourOver.Events,{
      initialize: function(){},
      getMatchSet: function(){
        throw "No get match set function specified"
      },
      getFilterState: function(){
        throw "No get filter state specified";
      },
      template: function(){
        throw "No template specified"
      },
      render: function(){
        var filter_state = this.getFilterState(),
            output = this.template({state:filter_state});
        return output
      },
      // Pass in a MatchSet that only has a single query of a chain of OR'ed queried and receive
      // an array of possibility names that have been selected.
      getSimpleSelectState: function(match_set,s,output){
          if(typeof(match_set) === "undefined" || !match_set || !match_set.stack){return false}
          if(typeof(s) === "undefined"){s = match_set.stack}
          if(typeof(output) === "undefined"){output = []}
          if(s.length < 1){
            return output;
          } else if (typeof(s[0][0]) === "object"){
            output.push(s[0][1]);
            return this.getSimpleSelectState(match_set,_.rest(s),output);
          } else if (s[0][0] === "or"){
            output = output.concat(this.getSimpleSelectState(match_set,s[0][1]));
            return this.getSimpleSelectState(match_set,_.rest(s),output);
          } else {
            throw "This does not appear to be a valid, simple selectElement stack."
          }
      },
      getIntersectedSelectState: function(match_set,s,output){
          if(typeof(match_set) === "undefined" || !match_set || !match_set.stack){return false}
          if(typeof(s) === "undefined"){s = match_set.stack}
          if(typeof(output) === "undefined"){output = []}
          if(s.length < 1){
            return output;
          } else if (typeof(s[0][0]) === "object"){
            output.push(s[0][1]);
            return this.getIntersectedSelectState(match_set,_.rest(s),output);
          } else if (s[0][0] === "and"){
            output = output.concat(this.getIntersectedSelectState(match_set,s[0][1]));
            return this.getIntersectedSelectState(match_set,_.rest(s),output);
          } else {
            throw "This does not appear to be a valid, simple selectElement stack."
          }
      },

      // Pass in a MatchSet that is the result of a single, non-compounded range and receive the
      // value of that range.
      getSimpleRangeState: function(match_set){
        if(typeof(match_set) === "undefined" || !match_set || !match_set.stack){return false}
        stack = match_set.stack;
        if(stack.length !== 1 || stack[0][1].length !== 2){throw "The filter specified does not appear to have a simple range stack."}
        return stack[0][1];
      }

      // TODO: Added more UI gets.
    });


    // From Backbone
    // Helper function to correctly set up the prototype chain, for subclasses.
      // Similar to `goog.inherits`, but uses a hash of prototype properties and
      // class properties to be extended.
      PourOver.extend = function(protoProps, staticProps) {
          var parent = this;
          var child;

          // The constructor function for the new subclass is either defined by you
          // (the "constructor" property in your `extend` definition), or defaulted
          // by us to simply call the parent's constructor.
          if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
          } else {
            child = function() {
              return parent.apply(this, arguments);
            };
          }

          // Add static properties to the constructor function, if supplied.
          _.extend(child, parent, staticProps);

          // Set the prototype chain to inherit from `parent`, without calling
          // `parent`'s constructor function.
          var Surrogate = function() {
              this.constructor = child;
            };
          Surrogate.prototype = parent.prototype;
          child.prototype = new Surrogate;

          // Add prototype properties (instance properties) to the subclass,
          // if supplied.
          if (protoProps) _.extend(child.prototype, protoProps);

          // Set a convenience property in case the parent's prototype is needed
          // later.
          child.__super__ = parent.prototype;

          return child;
        };


      PourOver.Collection.extend = PourOver.View.extend = PourOver.Filter.extend = PourOver.Sort.extend = PourOver.MatchSet.extend = PourOver.UI.Element.extend = PourOver.extend

      // #Presets

      // A PourOver buffered collection is one that stores some or all of its data as a promise. This is useful in conjunction with a
      // large data set in which you don't want to load all the data at page open.
      PourOver.BufferedCollection = PourOver.Collection.extend({
        initialize: function(){
            this.buffered_items = {};
        },
        stripFutures: function(item){
          return _.reduce(item,function(m,v,k){if(typeof(v) != "undefined"){m[k] = v} return m},{});
        },

        // Overrides the base get function with one that buffers in whole values from the server
        get: function(cids,raw){
          if(typeof(raw) === "undefined"){raw = false}
          var items = PourOver.Collection.prototype.get.call(this,cids),
              that = this;
          if(raw){return items;}
          return _.map(items,function(i){
            var guid = i.guid, new_item;
            if(that.buffered_items.hasOwnProperty(guid)){
              return _.extend(that.buffered_items[guid],that.stripFutures(i));
            } else {
              return i;
            }
          });
        },
        getBy: function(attr_name,vals,sorted,raw){
          if(typeof(raw) === "undefined"){raw = false}
          var items = PourOver.Collection.prototype.getBy.call(this,attr_name,vals,sorted),
              that = this;
          if(raw){return items;}
          return _.map(items,function(i){
            var guid = i.guid, new_item;
            if(that.buffered_items.hasOwnProperty(guid)){
              return _.extend(that.buffered_items[guid],that.stripFutures(i));
            } else {
              return i;
            }
          });
        },

        // Retrieve a specific attr of a specific item from the buffer.
        getBufferedValue: function(guid,attr){
          if(this.buffered_items.hasOwnProperty(guid)){
            return this.buffered_items[guid][attr] || false;
          } else {
            return false;
          }
        },

        // Delete all buffered values for items in the collection.
        clearBufferedItems: function (){
          var buffered_items = this.buffered_items;
          for (var p in buffered_items){
            if (buffered_items.hasOwnProperty(p)){
                delete buffered_items[p];
            }
          }
        },

        // When instantiating a buffered collection you must provide this method. This is how a buffered collection
        // knows what URL to fetch new data from.
        getBufferUrl: function(guids){
          throw "You must override getBufferUrl;"
        },
        preprocessItem: function(item){
          return [item["guid"],item]
        },

        // Pull down new data for an array of guids from the server at the URL returned by getBufferUrl. When the request returns,
        // push the new values into the buffer. The deferred object is returned from this method so you can chain additional callbacks
        // onto the resolution such as a render action.
        bufferGuids: function(guids){
          var that = this;
          guids = _.select(guids,function(g){ return g &&  ! that.buffered_items.hasOwnProperty(g);});

          var buffurl = this.getBufferUrl(guids),
              url = buffurl[0],
              jsonpCallback = buffurl[1];
          if(guids.length > 0){
            return $.ajax({
              url: url,
              dataType:'jsonp',
              cache: true
            }).always(function(d){
              if(_.isArray(d)){
                items = _.map(d,that.preprocessItem,that);
                _.each(items,function(i){
                  that.buffered_items[i[0]] = i[1];
                });
              }
            });
          } else {
            return $.Deferred().resolve(false);
          }
        }
      });

      // A buffered view is the pair to a buffered collection. It calls the appropriate buffering methods of the buffered collection
      // so that you automatically get the benefits of buffering as you are paging through the view. If you use a buffered view with a buffered collection
      // you shouldn't need to call the buffering methods of the collection explicitly.
      PourOver.BufferedView = PourOver.View.extend({
        buffer_pages: 1,
        bufferAroundCurrentPage: function(){
          var current_page = this.current_page,
              low_bound = current_page - this.buffer_pages > 0 ? current_page - this.buffer_pages : 0,
              high_bound = current_page + this.buffer_pages,
              range = _.range(low_bound,high_bound + 1),
              that = this;
          range = _.map(range,function(page){
            return _.pluck(that.getCurrentItems(page),"guid");
          });
          var guids = _.flatten(range);
          buffer_deferred = this.collection.bufferGuids(guids);
          buffer_deferred.done(function(d){
              if(d){
                that.render();
              }
          })
        },
        bufferRender: function(){
          var guids = _.pluck(this.getCurrentItems(),'guid'),
              buffer_deferred = this.collection.bufferGuids(guids);
          buffer_deferred.done(_.bind(function(){
            this.render()
          },this));
        },
        page: function(dir){
          PourOver.View.prototype.page.call(this,dir);
          this.bufferAroundCurrentPage();
        },
        pageTo: function(cid,silent){
          if(typeof(silent) === "undefined"){
            silent = false;
          }
          PourOver.View.prototype.pageTo.call(this,cid,silent);
          this.bufferAroundCurrentPage();
        }
      })

      // ## Filter defaults
      //
      // A strange filter that selects items based on an explicit list of cids. This is useful when you want to use PourOver in association
      // with, say, an editorially composed list of items or any mechanic in which you can "select" items to be included in a filter independent of
      // any attribute.
      PourOver.manualFilter = PourOver.Filter.extend({
        cacheResults: function(){return false},
        addCacheResults: function(){return false},
        getFn: function(query){
          if(_.isArray(query)){
            query = query.sort(function(a,b){return a - b})
            return new PourOver.MatchSet(query,this.getCollection(),[[this,query]]);
          } else if (typeof(query) === "number") {
            return new PourOver.MatchSet([query],this.getCollection(),[[this,query]]);
          } else {
            throw "Manual filters only support querying by one or more cids"
          }
        },
        addItems: function(cids){
          if(! _.isArray(cids)){cids = [cids]}
          cids = cids.sort(function(a,b){return a - b});
          if(this.current_query){
            var current_query = this.current_query.cids,
                new_query = PourOver.union_sorted(current_query,cids);
          } else {
            var new_query = cids;
          }
          this.query(new_query);
        },
        removeItems: function(cids){
          if(! _.isArray(cids)){cids = [cids]}
          cids = cids.sort(function(a,b){return a - b});
          var current_query = this.current_query.cids,
              new_query = PourOver.subtract_sorted(current_query,cids);
          this.query(new_query);
        }
      });

      // The convenience constructor for manual filters.
      PourOver.makeManualFilter = function(name){
        var filter = new PourOver.manualFilter(name,[]);
        return filter;
      }

      // An exact filter is the most commonly used filter. Given an attribute and a list of possibilities, an exact filter will bucket the items
      // into those satisfying each of the possibilities. This also has the fastest peformance as far as creating and updating.
      PourOver.exactFilter = PourOver.Filter.extend({
        cacheResults: PourOver.cacheMethods.exactCache,
        addCacheResults: PourOver.cacheMethods.exactAddCache,
        getFn: function(query){
          var that = this;
          if(_.isArray(query)){
            var match_set = _.reduce(query,function(m,i){
              if(!m){
                return that.getFn(i);
              } else {
                return m.or(that.getFn(i));
              }
            },false);
            return match_set;
          } else {
            var possibility = this.possibilities[query];
            if (_.isUndefined(possibility) ) throw "The filter " + this.name + " does not have a match for the query '" + query + "'.";
            return new PourOver.MatchSet(possibility.matching_cids,this.getCollection(),[[this,query]]);
          }
        }
      });

      // The convenience constructor for exact filters.
      PourOver.makeExactFilter = function(name,values,opts){
        if(typeof(opts) === "undefined"){opts = {}}
        var attr = opts.attr || name;
        values = _.map(values,function(i){return {value:i}});
        opts = _.extend({associated_attrs: [attr]},opts);
        return new PourOver.exactFilter(name,values,opts);
      }

      PourOver.inclusionFilter = PourOver.exactFilter.extend({
        cacheResults: PourOver.cacheMethods.inclusionCache,
        addCacheResults: PourOver.cacheMethods.inclusionAddCache
      });

      PourOver.makeInclusionFilter = function(name,values,opts){
        if(typeof(opts) === "undefined"){opts = {}}
        var attr = opts.attr || name;
        values = _.map(values,function(i){return {value:i}});
        opts = _.extend({associated_attrs: [attr]},opts);
        return new PourOver.inclusionFilter(name,values,opts);
      };

      // A range filter is for dividing items into buckets of ranges based on a specific attribute. A good example is, say, each item as 0-1000 "friends", then you can
      // supply a range filter with the possibilities: [[0,10],[11,100],[101,1000]] and it will create buckets for 0-10, 11-100, and 101 + friends.
      PourOver.rangeFilter = PourOver.Filter.extend({
        cacheResults: PourOver.cacheMethods.defaultCache,
        addCacheResults: PourOver.cacheMethods.defaultAddCache,
        fn: function(possibility,item){
          var attr = this.attr || this.name;
          return possibility.low <= item[attr] && possibility.high >= item[attr]
        },
        getFn: function(query){
          var possibility = this.possibilities[query.join("-")];
          if (_.isUndefined(possibility) ) throw "The filter " + this.name + " does not have a match for the query '" + query + "'.";
          return new PourOver.MatchSet(possibility.matching_cids,this.getCollection(),[[this,query]]);
        }
      });

      // The convenience constructor for range filters.
      PourOver.makeRangeFilter = function(name,ranges,opts){
        if(typeof(opts) === "undefined"){opts = {}}
        var values = _.map(ranges,function(r){return {low: r[0], high: r[1], value: r.join("-")}}),
            attr = opts.attr || name,
            newopts = _.extend({associated_attrs: [attr]},opts),
            filter = new PourOver.rangeFilter(name,values,newopts);
        return filter;
      }

      // The inverse of a range filter. Again each item has single value for a certain attribute, but the possibilities you provide are every value of that attribute.
      // Then, you query by a range. So, if a person can have 1-10 hats, you would feed a dv range filter the possibilities [1,2,3,4,5,6,7,8,9,10] and then make
      // queries such as [2,5] for 2-5 hats. Do not use this for huge ranges like 1-100. Use crossfilter or write some optimized way of doing this. PourOver is not optimized
      // for that kind of continuous query.
      PourOver.dvrangeFilter = PourOver.Filter.extend({
        cacheResults:  PourOver.cacheMethods.exactCache,
        addCacheResults: PourOver.cacheMethods.exactAddCache,
        getFn: function(query){
          if(! query[0] || ! query[1]){
            return new PourOver.MatchSet([],this.getCollection(),[[this,query]]);
          }
          var li,hi,that,possibilities,cids;
          li = _.indexOf(this.values,query[0]);
          hi = _.indexOf(this.values,query[1]);
          that = this;
          possibilities = _.map(this.values.slice(li,hi+1),function(p){return that.possibilities[p]});
          cids = _.reduce(possibilities,function(m,i){ return PourOver.union_sorted(m,i.matching_cids) },[]);
          return new PourOver.MatchSet(cids,this.getCollection(),[[this,query]]);
        }
      });

      // The convenience constructor for dv range filters.
      PourOver.makeDVrangeFilter = function(name,v,opts){
        if(typeof(opts) === "undefined"){opts = {}}
        var values = _.map(v,function(i){return {value:i}}),
            attr = opts.attr || name,
            newopts = _.extend({associated_attrs: [attr]},opts),
            filter = new PourOver.dvrangeFilter(name,values,newopts);
        return filter
      }

      // Filter for data with a continuous range or many possible values, such as dates, floats, etc.
      // Query with a scalar to query by exact value, or query with a length-2 array to
      // query a range (as in dvrangeFilter) such that the value is greater than or equal
      // to range[0] and less than range[1].
      PourOver.continuousRangeFilter = PourOver.Filter.extend({
        cacheResults: function(items){
          this.values = _.map(items,function(i) { return {cid: i.cid, val: i[this.name]}; }, this);
          this.values.sort(function(a,b) { return a.val-b.val });
        },
        addCacheResults: function(items){
          this.values = this.values.concat(items);
          this.values.sort(function(a,b) { return a.val-b.val });
        },
        getFn: function(query){
          var li,hi;
          var n = this.values.length;

          var bisect = PourOver.bisect_by( function(a) { return a.val });

          if(_.isArray(query)){
            // range filter
            if(_.isUndefined(query[0]) || _.isUndefined(query[1])){
              return new PourOver.MatchSet([],this.getCollection(),[[this,query]]);
            }
            li = bisect.left(this.values, query[0], 0, n);
            hi = bisect.left(this.values, query[1], 0, n);
          } else {
            // exact filter
            if(_.isUndefined(query)){
              return new PourOver.MatchSet([],this.getCollection(),[[this,query]]);
            }

            li = bisect.left(this.values, query, 0, n);
            hi = bisect.right(this.values, query, 0, n);
          }

          var cids = [];
          var i=li;
          while(i<hi) {
            cids.push(this.values[i].cid);
            ++i;
          }
          cids.sort(function(a,b) { return a-b });
          return new PourOver.MatchSet(cids,this.getCollection(),[[this,query]]);
        }
      });

      // The convenience constructor for continuous range filters.
      PourOver.makeContinuousRangeFilter = function(name,opts){
        if(typeof(opts) === "undefined"){opts = {}}
        var attr = opts.attr || name,
            newopts = _.extend({associated_attrs: [attr]},opts),
            filter = new PourOver.continuousRangeFilter(name,newopts);
        return filter;
      }

      // ## Preset sorts
      //
      // Sorts items based on an explicit ordering of values. This would be useful for, say, a slideshow in which
      // the order of items has nothing to do with any of their filterable attributes. Comes with methods to reorganize
      // the items in the sort.
      PourOver.explicitSort = PourOver.Sort.extend({
        fn: function(a,b){
          var a_index = _.indexOf(this.order,a[this.attr]),
              b_index = _.indexOf(this.order,b[this.attr]);
          if(a_index === -1) {a_index = 1/0}
          if(b_index === -1) {b_index = 1/0}
          return a_index - b_index;
        },
        reset: function(items){
          this.order = _.pluck(items,this.attr);
          this.rebuild_sort();
        },

        // Insert an item into the sort.
        insert: function(items,index){
          if(typeof(index) === "undefined"){index = this.order.length}
          if(! _.isArray(items)){items = [items]}
          var new_order = _.pluck(items,this.attr),
              args = [index,0].concat(new_order);
          this.order.splice.apply(this.order,args);
          this.rebuild_sort();
        },

        // Remove an item from the sort.
        remove: function(items){
          if(! _.isArray(items)){items = [items]}
          var attrs = _.pluck(items,this.attr);
          this.order = _.difference(this.order,attrs);
          this.rebuild_sort();
        },

        // Move an item from one place to another in the sort.
        move: function(items,index){
          if(! _.isArray(items)){items = [items]}
          var attrs = _.pluck(items,this.attr);
          this.order = _.map(this.order,function(o){ return _.include(attrs,o) ? null : o });
          this.insert(items,index);
          this.order = _.compact(this.order);
        }
      });

      // The convenience constructor for an explicit sort.
      PourOver.makeExplicitSort = function(name,collection,attr,order,opts){
        var sort = new PourOver.explicitSort(name,opts);
        sort.associated_attrs = [attr];
        sort.order = order;
        return sort;
      }

      PourOver.reverseCidSort = PourOver.Sort.extend({
        fn: function(a,b){
            return b.cid - a.cid;
        }
      })

      PourOver.makeReverseCidSort = function(name,collection){
        var sort = new PourOver.reverseCidSort(name);
        sort.associated_attrs = ["cid"];
        return sort;
      }

      // ## Preset UI elements
      //
      // A simple select element is roughly equavalent to elements such as a checklist or a radio list.
      // Items can only be unioned together. One or more selected.
      PourOver.UI.SimpleSelectElement = PourOver.UI.Element.extend({
        initialize: function(opts){
          if(!opts.filter){throw "A simple select element must have a filter specified"}
          this.filter = opts.filter;
        },
        getMatchSet: function(){
          return this.filter.current_query;
        },
        getFilterState: function(){
          var match_set = this.getMatchSet();
          return this.getSimpleSelectState(match_set)
        }
      });

      // A dv range element can be used for a slider in which you set the low and high and the query
      // corresponds to everything in between.
      PourOver.UI.SimpleDVRangeElement = PourOver.UI.Element.extend({
        initialize: function(opts){
          if(!opts.filter){throw "A simple dv range element must have a filter specified"}
          this.filter = opts.filter;
        },
        getMatchSet: function(){
          return this.filter.current_query;
        },
        getFilterState: function(){
          var match_set = this.getMatchSet();
          return this.getSimpleRangeState(match_set)
        }
      });

    return PourOver;
})();
return PourOver;
});


/*!
 * Pusher JavaScript Library v2.2.0
 * http://pusherapp.com/
 *
 * Copyright 2013, Pusher
 * Released under the MIT licence.
 */

(function(lib){
    if(typeof define === 'function' && define.amd){
        define('pusher',[],lib);
    } else {
        window.Pusher = lib();
    }
}(function(){
    (function(){function b(a,d){(null===a||void 0===a)&&b.warn("Warning","You must pass your app key when you instantiate Pusher.");d=d||{};var c=this;this.key=a;this.config=b.Util.extend(b.getGlobalConfig(),d.cluster?b.getClusterConfig(d.cluster):{},d);this.channels=new b.Channels;this.global_emitter=new b.EventsDispatcher;this.sessionID=Math.floor(1E9*Math.random());this.timeline=new b.Timeline(this.key,this.sessionID,{cluster:this.config.cluster,features:b.Util.getClientFeatures(),params:this.config.timelineParams||
    {},limit:50,level:b.Timeline.INFO,version:b.VERSION});this.config.disableStats||(this.timelineSender=new b.TimelineSender(this.timeline,{host:this.config.statsHost,path:"/timeline/v2/jsonp"}));this.connection=new b.ConnectionManager(this.key,b.Util.extend({getStrategy:function(a){a=b.Util.extend({},c.config,a);return b.StrategyBuilder.build(b.getDefaultStrategy(a),a)},timeline:this.timeline,activityTimeout:this.config.activity_timeout,pongTimeout:this.config.pong_timeout,unavailableTimeout:this.config.unavailable_timeout},
    this.config,{encrypted:this.isEncrypted()}));this.connection.bind("connected",function(){c.subscribeAll();c.timelineSender&&c.timelineSender.send(c.connection.isEncrypted())});this.connection.bind("message",function(a){var d=0===a.event.indexOf("pusher_internal:");if(a.channel){var b=c.channel(a.channel);b&&b.handleEvent(a.event,a.data)}d||c.global_emitter.emit(a.event,a.data)});this.connection.bind("disconnected",function(){c.channels.disconnect()});this.connection.bind("error",function(a){b.warn("Error",
    a)});b.instances.push(this);this.timeline.info({instances:b.instances.length});b.isReady&&c.connect()}var c=b.prototype;b.instances=[];b.isReady=!1;b.debug=function(){b.log&&b.log(b.Util.stringify.apply(this,arguments))};b.warn=function(){var a=b.Util.stringify.apply(this,arguments);window.console&&(window.console.warn?window.console.warn(a):window.console.log&&window.console.log(a));b.log&&b.log(a)};b.ready=function(){b.isReady=!0;for(var a=0,d=b.instances.length;a<d;a++)b.instances[a].connect()};
    c.channel=function(a){return this.channels.find(a)};c.allChannels=function(){return this.channels.all()};c.connect=function(){this.connection.connect();if(this.timelineSender&&!this.timelineSenderTimer){var a=this.connection.isEncrypted(),d=this.timelineSender;this.timelineSenderTimer=new b.PeriodicTimer(6E4,function(){d.send(a)})}};c.disconnect=function(){this.connection.disconnect();this.timelineSenderTimer&&(this.timelineSenderTimer.ensureAborted(),this.timelineSenderTimer=null)};c.bind=function(a,
    d){this.global_emitter.bind(a,d);return this};c.bind_all=function(a){this.global_emitter.bind_all(a);return this};c.subscribeAll=function(){for(var a in this.channels.channels)this.channels.channels.hasOwnProperty(a)&&this.subscribe(a)};c.subscribe=function(a){a=this.channels.add(a,this);"connected"===this.connection.state&&a.subscribe();return a};c.unsubscribe=function(a){a=this.channels.remove(a);"connected"===this.connection.state&&a.unsubscribe()};c.send_event=function(a,d,b){return this.connection.send_event(a,
    d,b)};c.isEncrypted=function(){return"https:"===b.Util.getDocument().location.protocol?!0:Boolean(this.config.encrypted)};b.HTTP={};this.Pusher=b}).call(this);
    (function(){function b(a){window.clearTimeout(a)}function c(a){window.clearInterval(a)}function a(a,d,b,c){var k=this;this.clear=d;this.timer=a(function(){null!==k.timer&&(k.timer=c(k.timer))},b)}var d=a.prototype;d.isRunning=function(){return null!==this.timer};d.ensureAborted=function(){this.timer&&(this.clear(this.timer),this.timer=null)};Pusher.Timer=function(d,c){return new a(setTimeout,b,d,function(a){c();return null})};Pusher.PeriodicTimer=function(d,b){return new a(setInterval,c,d,function(a){b();
    return a})}}).call(this);
    (function(){Pusher.Util={now:function(){return Date.now?Date.now():(new Date).valueOf()},defer:function(b){return new Pusher.Timer(0,b)},extend:function(b){for(var c=1;c<arguments.length;c++){var a=arguments[c],d;for(d in a)b[d]=a[d]&&a[d].constructor&&a[d].constructor===Object?Pusher.Util.extend(b[d]||{},a[d]):a[d]}return b},stringify:function(){for(var b=["Pusher"],c=0;c<arguments.length;c++)"string"===typeof arguments[c]?b.push(arguments[c]):void 0===window.JSON?b.push(arguments[c].toString()):b.push(JSON.stringify(arguments[c]));
    return b.join(" : ")},arrayIndexOf:function(b,c){var a=Array.prototype.indexOf;if(null===b)return-1;if(a&&b.indexOf===a)return b.indexOf(c);for(var a=0,d=b.length;a<d;a++)if(b[a]===c)return a;return-1},objectApply:function(b,c){for(var a in b)Object.prototype.hasOwnProperty.call(b,a)&&c(b[a],a,b)},keys:function(b){var c=[];Pusher.Util.objectApply(b,function(a,d){c.push(d)});return c},values:function(b){var c=[];Pusher.Util.objectApply(b,function(a){c.push(a)});return c},apply:function(b,c,a){for(var d=
    0;d<b.length;d++)c.call(a||window,b[d],d,b)},map:function(b,c){for(var a=[],d=0;d<b.length;d++)a.push(c(b[d],d,b,a));return a},mapObject:function(b,c){var a={};Pusher.Util.objectApply(b,function(d,b){a[b]=c(d)});return a},filter:function(b,c){c=c||function(a){return!!a};for(var a=[],d=0;d<b.length;d++)c(b[d],d,b,a)&&a.push(b[d]);return a},filterObject:function(b,c){var a={};Pusher.Util.objectApply(b,function(d,h){if(c&&c(d,h,b,a)||Boolean(d))a[h]=d});return a},flatten:function(b){var c=[];Pusher.Util.objectApply(b,
    function(a,d){c.push([d,a])});return c},any:function(b,c){for(var a=0;a<b.length;a++)if(c(b[a],a,b))return!0;return!1},all:function(b,c){for(var a=0;a<b.length;a++)if(!c(b[a],a,b))return!1;return!0},method:function(b){var c=Array.prototype.slice.call(arguments,1);return function(a){return a[b].apply(a,c.concat(arguments))}},getWindow:function(){return window},getDocument:function(){return document},getNavigator:function(){return navigator},getLocalStorage:function(){try{return window.localStorage}catch(b){}},
    getClientFeatures:function(){return Pusher.Util.keys(Pusher.Util.filterObject({ws:Pusher.WSTransport,flash:Pusher.FlashTransport},function(b){return b.isSupported({})}))},addWindowListener:function(b,c){var a=Pusher.Util.getWindow();void 0!==a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c)},removeWindowListener:function(b,c){var a=Pusher.Util.getWindow();void 0!==a.addEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c)},isXHRSupported:function(){var b=window.XMLHttpRequest;
    return Boolean(b)&&void 0!==(new b).withCredentials},isXDRSupported:function(b){b=b?"https:":"http:";var c=Pusher.Util.getDocument().location.protocol;return Boolean(window.XDomainRequest)&&c===b}}}).call(this);
    (function(){Pusher.VERSION="2.2.0";Pusher.PROTOCOL=7;Pusher.host="ws.pusherapp.com";Pusher.ws_port=80;Pusher.wss_port=443;Pusher.sockjs_host="sockjs.pusher.com";Pusher.sockjs_http_port=80;Pusher.sockjs_https_port=443;Pusher.sockjs_path="/pusher";Pusher.stats_host="stats.pusher.com";Pusher.channel_auth_endpoint="/pusher/auth";Pusher.channel_auth_transport="ajax";Pusher.activity_timeout=12E4;Pusher.pong_timeout=3E4;Pusher.unavailable_timeout=1E4;Pusher.cdn_http="http://js.pusher.com/";Pusher.cdn_https=
    "https://d3dy5gmtp8yhk7.cloudfront.net/";Pusher.dependency_suffix=".min";Pusher.getDefaultStrategy=function(b){return[[":def","ws_options",{hostUnencrypted:b.wsHost+":"+b.wsPort,hostEncrypted:b.wsHost+":"+b.wssPort}],[":def","wss_options",[":extend",":ws_options",{encrypted:!0}]],[":def","sockjs_options",{hostUnencrypted:b.httpHost+":"+b.httpPort,hostEncrypted:b.httpHost+":"+b.httpsPort}],[":def","timeouts",{loop:!0,timeout:15E3,timeoutLimit:6E4}],[":def","ws_manager",[":transport_manager",{lives:2,
    minPingDelay:1E4,maxPingDelay:b.activity_timeout}]],[":def","streaming_manager",[":transport_manager",{lives:2,minPingDelay:1E4,maxPingDelay:b.activity_timeout}]],[":def_transport","ws","ws",3,":ws_options",":ws_manager"],[":def_transport","wss","ws",3,":wss_options",":ws_manager"],[":def_transport","flash","flash",2,":ws_options",":ws_manager"],[":def_transport","sockjs","sockjs",1,":sockjs_options"],[":def_transport","xhr_streaming","xhr_streaming",1,":sockjs_options",":streaming_manager"],[":def_transport",
    "xdr_streaming","xdr_streaming",1,":sockjs_options",":streaming_manager"],[":def_transport","xhr_polling","xhr_polling",1,":sockjs_options"],[":def_transport","xdr_polling","xdr_polling",1,":sockjs_options"],[":def","ws_loop",[":sequential",":timeouts",":ws"]],[":def","wss_loop",[":sequential",":timeouts",":wss"]],[":def","flash_loop",[":sequential",":timeouts",":flash"]],[":def","sockjs_loop",[":sequential",":timeouts",":sockjs"]],[":def","streaming_loop",[":sequential",":timeouts",[":if",[":is_supported",
    ":xhr_streaming"],":xhr_streaming",":xdr_streaming"]]],[":def","polling_loop",[":sequential",":timeouts",[":if",[":is_supported",":xhr_polling"],":xhr_polling",":xdr_polling"]]],[":def","http_loop",[":if",[":is_supported",":streaming_loop"],[":best_connected_ever",":streaming_loop",[":delayed",4E3,[":polling_loop"]]],[":polling_loop"]]],[":def","http_fallback_loop",[":if",[":is_supported",":http_loop"],[":http_loop"],[":sockjs_loop"]]],[":def","strategy",[":cached",18E5,[":first_connected",[":if",
    [":is_supported",":ws"],b.encrypted?[":best_connected_ever",":ws_loop",[":delayed",2E3,[":http_fallback_loop"]]]:[":best_connected_ever",":ws_loop",[":delayed",2E3,[":wss_loop"]],[":delayed",5E3,[":http_fallback_loop"]]],[":if",[":is_supported",":flash"],[":best_connected_ever",":flash_loop",[":delayed",2E3,[":http_fallback_loop"]]],[":http_fallback_loop"]]]]]]]}}).call(this);
    (function(){Pusher.getGlobalConfig=function(){return{wsHost:Pusher.host,wsPort:Pusher.ws_port,wssPort:Pusher.wss_port,httpHost:Pusher.sockjs_host,httpPort:Pusher.sockjs_http_port,httpsPort:Pusher.sockjs_https_port,httpPath:Pusher.sockjs_path,statsHost:Pusher.stats_host,authEndpoint:Pusher.channel_auth_endpoint,authTransport:Pusher.channel_auth_transport,activity_timeout:Pusher.activity_timeout,pong_timeout:Pusher.pong_timeout,unavailable_timeout:Pusher.unavailable_timeout}};Pusher.getClusterConfig=
    function(b){return{wsHost:"ws-"+b+".pusher.com",httpHost:"sockjs-"+b+".pusher.com"}}}).call(this);(function(){function b(b){var a=function(a){Error.call(this,a);this.name=b};Pusher.Util.extend(a.prototype,Error.prototype);return a}Pusher.Errors={BadEventName:b("BadEventName"),RequestTimedOut:b("RequestTimedOut"),TransportPriorityTooLow:b("TransportPriorityTooLow"),TransportClosed:b("TransportClosed"),UnsupportedTransport:b("UnsupportedTransport"),UnsupportedStrategy:b("UnsupportedStrategy")}}).call(this);
    (function(){function b(a){this.callbacks=new c;this.global_callbacks=[];this.failThrough=a}function c(){this._callbacks={}}var a=b.prototype;a.bind=function(a,b,c){this.callbacks.add(a,b,c);return this};a.bind_all=function(a){this.global_callbacks.push(a);return this};a.unbind=function(a,b,c){this.callbacks.remove(a,b,c);return this};a.unbind_all=function(a,b){this.callbacks.remove(a,b);return this};a.emit=function(a,b){var c;for(c=0;c<this.global_callbacks.length;c++)this.global_callbacks[c](a,b);
    var e=this.callbacks.get(a);if(e&&0<e.length)for(c=0;c<e.length;c++)e[c].fn.call(e[c].context||window,b);else this.failThrough&&this.failThrough(a,b);return this};c.prototype.get=function(a){return this._callbacks["_"+a]};c.prototype.add=function(a,b,c){a="_"+a;this._callbacks[a]=this._callbacks[a]||[];this._callbacks[a].push({fn:b,context:c})};c.prototype.remove=function(a,b,c){!a&&!b&&!c?this._callbacks={}:(a=a?["_"+a]:Pusher.Util.keys(this._callbacks),b||c?Pusher.Util.apply(a,function(a){this._callbacks[a]=
    Pusher.Util.filter(this._callbacks[a]||[],function(a){return b&&b!==a.fn||c&&c!==a.context});0===this._callbacks[a].length&&delete this._callbacks[a]},this):Pusher.Util.apply(a,function(a){delete this._callbacks[a]},this))};Pusher.EventsDispatcher=b}).call(this);
    (function(){function b(a,d){this.lastId=0;this.prefix=a;this.name=d}var c=b.prototype;c.create=function(a){this.lastId++;var d=this.lastId,b=this.prefix+d,c=this.name+"["+d+"]",e=!1,g=function(){e||(a.apply(null,arguments),e=!0)};this[d]=g;return{number:d,id:b,name:c,callback:g}};c.remove=function(a){delete this[a.number]};Pusher.ScriptReceiverFactory=b;Pusher.ScriptReceivers=new b("_pusher_script_","Pusher.ScriptReceivers")}).call(this);
    (function(){function b(a){this.src=a}var c=b.prototype;c.send=function(a){var d=this,b="Error loading "+d.src;d.script=document.createElement("script");d.script.id=a.id;d.script.src=d.src;d.script.type="text/javascript";d.script.charset="UTF-8";d.script.addEventListener?(d.script.onerror=function(){a.callback(b)},d.script.onload=function(){a.callback(null)}):d.script.onreadystatechange=function(){("loaded"===d.script.readyState||"complete"===d.script.readyState)&&a.callback(null)};void 0===d.script.async&&
    document.attachEvent&&/opera/i.test(navigator.userAgent)?(d.errorScript=document.createElement("script"),d.errorScript.id=a.id+"_error",d.errorScript.text=a.name+"('"+b+"');",d.script.async=d.errorScript.async=!1):d.script.async=!0;var c=document.getElementsByTagName("head")[0];c.insertBefore(d.script,c.firstChild);d.errorScript&&c.insertBefore(d.errorScript,d.script.nextSibling)};c.cleanup=function(){this.script&&(this.script.onload=this.script.onerror=null,this.script.onreadystatechange=null);this.script&&
    this.script.parentNode&&this.script.parentNode.removeChild(this.script);this.errorScript&&this.errorScript.parentNode&&this.errorScript.parentNode.removeChild(this.errorScript);this.errorScript=this.script=null};Pusher.ScriptRequest=b}).call(this);
    (function(){function b(a){this.options=a;this.receivers=a.receivers||Pusher.ScriptReceivers;this.loading={}}var c=b.prototype;c.load=function(a,d){var b=this;if(b.loading[a]&&0<b.loading[a].length)b.loading[a].push(d);else{b.loading[a]=[d];var c=new Pusher.ScriptRequest(b.getPath(a)),e=b.receivers.create(function(d){b.receivers.remove(e);if(b.loading[a]){var k=b.loading[a];delete b.loading[a];for(var l=function(a){a||c.cleanup()},m=0;m<k.length;m++)k[m](d,l)}});c.send(e)}};c.getRoot=function(a){var d=
    Pusher.Util.getDocument().location.protocol;return(a&&a.encrypted||"https:"===d?this.options.cdn_https:this.options.cdn_http).replace(/\/*$/,"")+"/"+this.options.version};c.getPath=function(a,d){return this.getRoot(d)+"/"+a+this.options.suffix+".js"};Pusher.DependencyLoader=b}).call(this);
    (function(){function b(){Pusher.ready()}function c(a){document.body?a():setTimeout(function(){c(a)},0)}function a(){c(b)}Pusher.DependenciesReceivers=new Pusher.ScriptReceiverFactory("_pusher_dependencies","Pusher.DependenciesReceivers");Pusher.Dependencies=new Pusher.DependencyLoader({cdn_http:Pusher.cdn_http,cdn_https:Pusher.cdn_https,version:Pusher.VERSION,suffix:Pusher.dependency_suffix,receivers:Pusher.DependenciesReceivers});window.JSON?a():Pusher.Dependencies.load("json2",a)})();
    (function(){for(var b=String.fromCharCode,c=0;64>c;c++)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(c);var a=function(a){var d=a.charCodeAt(0);return 128>d?a:2048>d?b(192|d>>>6)+b(128|d&63):b(224|d>>>12&15)+b(128|d>>>6&63)+b(128|d&63)},d=function(a){var d=[0,2,1][a.length%3];a=a.charCodeAt(0)<<16|(1<a.length?a.charCodeAt(1):0)<<8|(2<a.length?a.charCodeAt(2):0);return["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a>>>18),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a>>>
    12&63),2<=d?"=":"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a>>>6&63),1<=d?"=":"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(a&63)].join("")},h=window.btoa||function(a){return a.replace(/[\s\S]{1,3}/g,d)};Pusher.Base64={encode:function(d){return h(d.replace(/[^\x00-\x7F]/g,a))}}}).call(this);
    (function(){function b(a,b){this.url=a;this.data=b}function c(a){return Pusher.Util.mapObject(a,function(a){"object"===typeof a&&(a=JSON.stringify(a));return encodeURIComponent(Pusher.Base64.encode(a.toString()))})}var a=b.prototype;a.send=function(a){if(!this.request){var b=Pusher.Util.filterObject(this.data,function(a){return void 0!==a}),b=Pusher.Util.map(Pusher.Util.flatten(c(b)),Pusher.Util.method("join","=")).join("&");this.request=new Pusher.ScriptRequest(this.url+"/"+a.number+"?"+b);this.request.send(a)}};
    a.cleanup=function(){this.request&&this.request.cleanup()};Pusher.JSONPRequest=b}).call(this);
    (function(){function b(a,b,c){this.key=a;this.session=b;this.events=[];this.options=c||{};this.uniqueID=this.sent=0}var c=b.prototype;b.ERROR=3;b.INFO=6;b.DEBUG=7;c.log=function(a,b){a<=this.options.level&&(this.events.push(Pusher.Util.extend({},b,{timestamp:Pusher.Util.now()})),this.options.limit&&this.events.length>this.options.limit&&this.events.shift())};c.error=function(a){this.log(b.ERROR,a)};c.info=function(a){this.log(b.INFO,a)};c.debug=function(a){this.log(b.DEBUG,a)};c.isEmpty=function(){return 0===
    this.events.length};c.send=function(a,b){var c=this,f=Pusher.Util.extend({session:c.session,bundle:c.sent+1,key:c.key,lib:"js",version:c.options.version,cluster:c.options.cluster,features:c.options.features,timeline:c.events},c.options.params);c.events=[];a(f,function(a,g){a||c.sent++;b&&b(a,g)});return!0};c.generateUniqueID=function(){this.uniqueID++;return this.uniqueID};Pusher.Timeline=b}).call(this);
    (function(){function b(b,a){this.timeline=b;this.options=a||{}}b.prototype.send=function(b,a){var d=this;d.timeline.isEmpty()||d.timeline.send(function(a,f){var e=new Pusher.JSONPRequest("http"+(b?"s":"")+"://"+(d.host||d.options.host)+d.options.path,a),g=Pusher.ScriptReceivers.create(function(a,b){Pusher.ScriptReceivers.remove(g);e.cleanup();b&&b.host&&(d.host=b.host);f&&f(a,b)});e.send(g)},a)};Pusher.TimelineSender=b}).call(this);
    (function(){function b(a){this.strategies=a}function c(a,b,c){var h=Pusher.Util.map(a,function(a,d,h,f){return a.connect(b,c(d,f))});return{abort:function(){Pusher.Util.apply(h,d)},forceMinPriority:function(a){Pusher.Util.apply(h,function(b){b.forceMinPriority(a)})}}}function a(a){return Pusher.Util.all(a,function(a){return Boolean(a.error)})}function d(a){!a.error&&!a.aborted&&(a.abort(),a.aborted=!0)}var h=b.prototype;h.isSupported=function(){return Pusher.Util.any(this.strategies,Pusher.Util.method("isSupported"))};
    h.connect=function(b,d){return c(this.strategies,b,function(b,c){return function(h,f){(c[b].error=h)?a(c)&&d(!0):(Pusher.Util.apply(c,function(a){a.forceMinPriority(f.transport.priority)}),d(null,f))}})};Pusher.BestConnectedEverStrategy=b}).call(this);
    (function(){function b(a,b,d){this.strategy=a;this.transports=b;this.ttl=d.ttl||18E5;this.encrypted=d.encrypted;this.timeline=d.timeline}function c(a){return"pusherTransport"+(a?"Encrypted":"Unencrypted")}function a(a){var b=Pusher.Util.getLocalStorage();if(b)try{var h=b[c(a)];if(h)return JSON.parse(h)}catch(k){d(a)}return null}function d(a){var b=Pusher.Util.getLocalStorage();if(b)try{delete b[c(a)]}catch(d){}}var h=b.prototype;h.isSupported=function(){return this.strategy.isSupported()};h.connect=
    function(b,h){var g=this.encrypted,k=a(g),l=[this.strategy];if(k&&k.timestamp+this.ttl>=Pusher.Util.now()){var m=this.transports[k.transport];m&&(this.timeline.info({cached:!0,transport:k.transport,latency:k.latency}),l.push(new Pusher.SequentialStrategy([m],{timeout:2*k.latency+1E3,failFast:!0})))}var p=Pusher.Util.now(),n=l.pop().connect(b,function s(a,k){if(a)d(g),0<l.length?(p=Pusher.Util.now(),n=l.pop().connect(b,s)):h(a);else{var m=k.transport.name,t=Pusher.Util.now()-p,r=Pusher.Util.getLocalStorage();
    if(r)try{r[c(g)]=JSON.stringify({timestamp:Pusher.Util.now(),transport:m,latency:t})}catch(u){}h(null,k)}});return{abort:function(){n.abort()},forceMinPriority:function(a){b=a;n&&n.forceMinPriority(a)}}};Pusher.CachedStrategy=b}).call(this);
    (function(){function b(a,b){this.strategy=a;this.options={delay:b.delay}}var c=b.prototype;c.isSupported=function(){return this.strategy.isSupported()};c.connect=function(a,b){var c=this.strategy,f,e=new Pusher.Timer(this.options.delay,function(){f=c.connect(a,b)});return{abort:function(){e.ensureAborted();f&&f.abort()},forceMinPriority:function(b){a=b;f&&f.forceMinPriority(b)}}};Pusher.DelayedStrategy=b}).call(this);
    (function(){function b(a){this.strategy=a}var c=b.prototype;c.isSupported=function(){return this.strategy.isSupported()};c.connect=function(a,b){var c=this.strategy.connect(a,function(a,e){e&&c.abort();b(a,e)});return c};Pusher.FirstConnectedStrategy=b}).call(this);
    (function(){function b(a,b,c){this.test=a;this.trueBranch=b;this.falseBranch=c}var c=b.prototype;c.isSupported=function(){return(this.test()?this.trueBranch:this.falseBranch).isSupported()};c.connect=function(a,b){return(this.test()?this.trueBranch:this.falseBranch).connect(a,b)};Pusher.IfStrategy=b}).call(this);
    (function(){function b(a,b){this.strategies=a;this.loop=Boolean(b.loop);this.failFast=Boolean(b.failFast);this.timeout=b.timeout;this.timeoutLimit=b.timeoutLimit}var c=b.prototype;c.isSupported=function(){return Pusher.Util.any(this.strategies,Pusher.Util.method("isSupported"))};c.connect=function(a,b){var c=this,f=this.strategies,e=0,g=this.timeout,k=null,l=function(m,p){p?b(null,p):(e+=1,c.loop&&(e%=f.length),e<f.length?(g&&(g*=2,c.timeoutLimit&&(g=Math.min(g,c.timeoutLimit))),k=c.tryStrategy(f[e],
    a,{timeout:g,failFast:c.failFast},l)):b(!0))},k=this.tryStrategy(f[e],a,{timeout:g,failFast:this.failFast},l);return{abort:function(){k.abort()},forceMinPriority:function(b){a=b;k&&k.forceMinPriority(b)}}};c.tryStrategy=function(a,b,c,f){var e=null,g=null;0<c.timeout&&(e=new Pusher.Timer(c.timeout,function(){g.abort();f(!0)}));g=a.connect(b,function(a,b){if(!a||!e||!e.isRunning()||c.failFast)e&&e.ensureAborted(),f(a,b)});return{abort:function(){e&&e.ensureAborted();g.abort()},forceMinPriority:function(a){g.forceMinPriority(a)}}};
    Pusher.SequentialStrategy=b}).call(this);
    (function(){function b(a,b,c,e){this.name=a;this.priority=b;this.transport=c;this.options=e||{}}function c(a,b){Pusher.Util.defer(function(){b(a)});return{abort:function(){},forceMinPriority:function(){}}}var a=b.prototype;a.isSupported=function(){return this.transport.isSupported({encrypted:this.options.encrypted})};a.connect=function(a,b){if(this.isSupported()){if(this.priority<a)return c(new Pusher.Errors.TransportPriorityTooLow,b)}else return c(new Pusher.Errors.UnsupportedStrategy,b);var f=this,
    e=!1,g=this.transport.createConnection(this.name,this.priority,this.options.key,this.options),k=null,l=function(){g.unbind("initialized",l);g.connect()},m=function(){k=new Pusher.Handshake(g,function(a){e=!0;q();b(null,a)})},p=function(a){q();b(a)},n=function(){q();b(new Pusher.Errors.TransportClosed(g))},q=function(){g.unbind("initialized",l);g.unbind("open",m);g.unbind("error",p);g.unbind("closed",n)};g.bind("initialized",l);g.bind("open",m);g.bind("error",p);g.bind("closed",n);g.initialize();return{abort:function(){e||
    (q(),k?k.close():g.close())},forceMinPriority:function(a){e||f.priority<a&&(k?k.close():g.close())}}};Pusher.TransportStrategy=b}).call(this);
    (function(){function b(a,b,c){return a+(b.encrypted?"s":"")+"://"+(b.encrypted?b.hostEncrypted:b.hostUnencrypted)+c}function c(a,b){return"/app/"+a+("?protocol="+Pusher.PROTOCOL+"&client=js&version="+Pusher.VERSION+(b?"&"+b:""))}Pusher.URLSchemes={ws:{getInitial:function(a,d){return b("ws",d,c(a,"flash=false"))}},flash:{getInitial:function(a,d){return b("ws",d,c(a,"flash=true"))}},sockjs:{getInitial:function(a,c){return b("http",c,c.httpPath||"/pusher","")},getPath:function(a,b){return c(a)}},http:{getInitial:function(a,
    d){var h=(d.httpPath||"/pusher")+c(a);return b("http",d,h)}}}}).call(this);
    (function(){function b(a,b,c,f,e){Pusher.EventsDispatcher.call(this);this.hooks=a;this.name=b;this.priority=c;this.key=f;this.options=e;this.state="new";this.timeline=e.timeline;this.activityTimeout=e.activityTimeout;this.id=this.timeline.generateUniqueID()}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.handlesActivityChecks=function(){return Boolean(this.hooks.handlesActivityChecks)};c.supportsPing=function(){return Boolean(this.hooks.supportsPing)};c.initialize=function(){var a=
    this;a.timeline.info(a.buildTimelineMessage({transport:a.name+(a.options.encrypted?"s":"")}));a.hooks.beforeInitialize&&a.hooks.beforeInitialize();if(a.hooks.isInitialized())a.changeState("initialized");else if(a.hooks.file)a.changeState("initializing"),Pusher.Dependencies.load(a.hooks.file,function(b,c){if(a.hooks.isInitialized())a.changeState("initialized"),c(!0);else{if(b)a.onError(b);a.onClose();c(!1)}});else a.onClose()};c.connect=function(){var a=this;if(a.socket||"initialized"!==a.state)return!1;
    var b=a.hooks.urls.getInitial(a.key,a.options);try{a.socket=a.hooks.getSocket(b,a.options)}catch(c){return Pusher.Util.defer(function(){a.onError(c);a.changeState("closed")}),!1}a.bindListeners();Pusher.debug("Connecting",{transport:a.name,url:b});a.changeState("connecting");return!0};c.close=function(){return this.socket?(this.socket.close(),!0):!1};c.send=function(a){var b=this;return"open"===b.state?(Pusher.Util.defer(function(){b.socket&&b.socket.send(a)}),!0):!1};c.ping=function(){"open"===this.state&&
    this.supportsPing()&&this.socket.ping()};c.onOpen=function(){this.hooks.beforeOpen&&this.hooks.beforeOpen(this.socket,this.hooks.urls.getPath(this.key,this.options));this.changeState("open");this.socket.onopen=void 0};c.onError=function(a){this.emit("error",{type:"WebSocketError",error:a});this.timeline.error(this.buildTimelineMessage({error:a.toString()}))};c.onClose=function(a){a?this.changeState("closed",{code:a.code,reason:a.reason,wasClean:a.wasClean}):this.changeState("closed");this.unbindListeners();
    this.socket=void 0};c.onMessage=function(a){this.emit("message",a)};c.onActivity=function(){this.emit("activity")};c.bindListeners=function(){var a=this;a.socket.onopen=function(){a.onOpen()};a.socket.onerror=function(b){a.onError(b)};a.socket.onclose=function(b){a.onClose(b)};a.socket.onmessage=function(b){a.onMessage(b)};a.supportsPing()&&(a.socket.onactivity=function(){a.onActivity()})};c.unbindListeners=function(){this.socket&&(this.socket.onopen=void 0,this.socket.onerror=void 0,this.socket.onclose=
    void 0,this.socket.onmessage=void 0,this.supportsPing()&&(this.socket.onactivity=void 0))};c.changeState=function(a,b){this.state=a;this.timeline.info(this.buildTimelineMessage({state:a,params:b}));this.emit(a,b)};c.buildTimelineMessage=function(a){return Pusher.Util.extend({cid:this.id},a)};Pusher.TransportConnection=b}).call(this);
    (function(){function b(a){this.hooks=a}var c=b.prototype;c.isSupported=function(a){return this.hooks.isSupported(a)};c.createConnection=function(a,b,c,f){return new Pusher.TransportConnection(this.hooks,a,b,c,f)};Pusher.Transport=b}).call(this);
    (function(){Pusher.WSTransport=new Pusher.Transport({urls:Pusher.URLSchemes.ws,handlesActivityChecks:!1,supportsPing:!1,isInitialized:function(){return Boolean(window.WebSocket||window.MozWebSocket)},isSupported:function(){return Boolean(window.WebSocket||window.MozWebSocket)},getSocket:function(a){return new (window.WebSocket||window.MozWebSocket)(a)}});Pusher.FlashTransport=new Pusher.Transport({file:"flashfallback",urls:Pusher.URLSchemes.flash,handlesActivityChecks:!1,supportsPing:!1,isSupported:function(){try{return Boolean(new ActiveXObject("ShockwaveFlash.ShockwaveFlash"))}catch(a){try{var b=
    Pusher.Util.getNavigator();return Boolean(b&&b.mimeTypes&&void 0!==b.mimeTypes["application/x-shockwave-flash"])}catch(c){return!1}}},beforeInitialize:function(){void 0===window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR&&(window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR=!0);window.WEB_SOCKET_SWF_LOCATION=Pusher.Dependencies.getRoot()+"/WebSocketMain.swf"},isInitialized:function(){return void 0!==window.FlashWebSocket},getSocket:function(a){return new FlashWebSocket(a)}});Pusher.SockJSTransport=
    new Pusher.Transport({file:"sockjs",urls:Pusher.URLSchemes.sockjs,handlesActivityChecks:!0,supportsPing:!1,isSupported:function(){return!0},isInitialized:function(){return void 0!==window.SockJS},getSocket:function(a,b){return new SockJS(a,null,{js_path:Pusher.Dependencies.getPath("sockjs",{encrypted:b.encrypted}),ignore_null_origin:b.ignoreNullOrigin})},beforeOpen:function(a,b){a.send(JSON.stringify({path:b}))}});var b={urls:Pusher.URLSchemes.http,handlesActivityChecks:!1,supportsPing:!0,isInitialized:function(){return Boolean(Pusher.HTTP.Socket)}},
    c=Pusher.Util.extend({getSocket:function(a){return Pusher.HTTP.getStreamingSocket(a)}},b),b=Pusher.Util.extend({getSocket:function(a){return Pusher.HTTP.getPollingSocket(a)}},b),a={file:"xhr",isSupported:Pusher.Util.isXHRSupported},d={file:"xdr",isSupported:function(a){return Pusher.Util.isXDRSupported(a.encrypted)}};Pusher.XHRStreamingTransport=new Pusher.Transport(Pusher.Util.extend({},c,a));Pusher.XDRStreamingTransport=new Pusher.Transport(Pusher.Util.extend({},c,d));Pusher.XHRPollingTransport=
    new Pusher.Transport(Pusher.Util.extend({},b,a));Pusher.XDRPollingTransport=new Pusher.Transport(Pusher.Util.extend({},b,d))}).call(this);
    (function(){function b(a,b,c){this.manager=a;this.transport=b;this.minPingDelay=c.minPingDelay;this.maxPingDelay=c.maxPingDelay;this.pingDelay=void 0}var c=b.prototype;c.createConnection=function(a,b,c,f){var e=this;f=Pusher.Util.extend({},f,{activityTimeout:e.pingDelay});var g=e.transport.createConnection(a,b,c,f),k=null,l=function(){g.unbind("open",l);g.bind("closed",m);k=Pusher.Util.now()},m=function(a){g.unbind("closed",m);1002===a.code||1003===a.code?e.manager.reportDeath():!a.wasClean&&k&&(a=
    Pusher.Util.now()-k,a<2*e.maxPingDelay&&(e.manager.reportDeath(),e.pingDelay=Math.max(a/2,e.minPingDelay)))};g.bind("open",l);return g};c.isSupported=function(a){return this.manager.isAlive()&&this.transport.isSupported(a)};Pusher.AssistantToTheTransportManager=b}).call(this);
    (function(){function b(a){this.options=a||{};this.livesLeft=this.options.lives||Infinity}var c=b.prototype;c.getAssistant=function(a){return new Pusher.AssistantToTheTransportManager(this,a,{minPingDelay:this.options.minPingDelay,maxPingDelay:this.options.maxPingDelay})};c.isAlive=function(){return 0<this.livesLeft};c.reportDeath=function(){this.livesLeft-=1};Pusher.TransportManager=b}).call(this);
    (function(){function b(a){return function(b){return[a.apply(this,arguments),b]}}function c(a,b){if(0===a.length)return[[],b];var h=d(a[0],b),f=c(a.slice(1),h[1]);return[[h[0]].concat(f[0]),f[1]]}function a(a,b){if("string"===typeof a[0]&&":"===a[0].charAt(0)){var h=b[a[0].slice(1)];if(1<a.length){if("function"!==typeof h)throw"Calling non-function "+a[0];var f=[Pusher.Util.extend({},b)].concat(Pusher.Util.map(a.slice(1),function(a){return d(a,Pusher.Util.extend({},b))[0]}));return h.apply(this,f)}return[h,
    b]}return c(a,b)}function d(b,c){if("string"===typeof b){var d;if("string"===typeof b&&":"===b.charAt(0)){d=c[b.slice(1)];if(void 0===d)throw"Undefined symbol "+b;d=[d,c]}else d=[b,c];return d}return"object"===typeof b&&b instanceof Array&&0<b.length?a(b,c):[b,c]}var h={ws:Pusher.WSTransport,flash:Pusher.FlashTransport,sockjs:Pusher.SockJSTransport,xhr_streaming:Pusher.XHRStreamingTransport,xdr_streaming:Pusher.XDRStreamingTransport,xhr_polling:Pusher.XHRPollingTransport,xdr_polling:Pusher.XDRPollingTransport},
    f={isSupported:function(){return!1},connect:function(a,b){var c=Pusher.Util.defer(function(){b(new Pusher.Errors.UnsupportedStrategy)});return{abort:function(){c.ensureAborted()},forceMinPriority:function(){}}}},e={extend:function(a,b,c){return[Pusher.Util.extend({},b,c),a]},def:function(a,b,c){if(void 0!==a[b])throw"Redefining symbol "+b;a[b]=c;return[void 0,a]},def_transport:function(a,b,c,d,e,n){var q=h[c];if(!q)throw new Pusher.Errors.UnsupportedTransport(c);c=(!a.enabledTransports||-1!==Pusher.Util.arrayIndexOf(a.enabledTransports,
    b))&&(!a.disabledTransports||-1===Pusher.Util.arrayIndexOf(a.disabledTransports,b))&&("flash"!==b||!0!==a.disableFlash)?new Pusher.TransportStrategy(b,d,n?n.getAssistant(q):q,Pusher.Util.extend({key:a.key,encrypted:a.encrypted,timeline:a.timeline,ignoreNullOrigin:a.ignoreNullOrigin},e)):f;d=a.def(a,b,c)[1];d.transports=a.transports||{};d.transports[b]=c;return[void 0,d]},transport_manager:b(function(a,b){return new Pusher.TransportManager(b)}),sequential:b(function(a,b){var c=Array.prototype.slice.call(arguments,
    2);return new Pusher.SequentialStrategy(c,b)}),cached:b(function(a,b,c){return new Pusher.CachedStrategy(c,a.transports,{ttl:b,timeline:a.timeline,encrypted:a.encrypted})}),first_connected:b(function(a,b){return new Pusher.FirstConnectedStrategy(b)}),best_connected_ever:b(function(){var a=Array.prototype.slice.call(arguments,1);return new Pusher.BestConnectedEverStrategy(a)}),delayed:b(function(a,b,c){return new Pusher.DelayedStrategy(c,{delay:b})}),"if":b(function(a,b,c,d){return new Pusher.IfStrategy(b,
    c,d)}),is_supported:b(function(a,b){return function(){return b.isSupported()}})};Pusher.StrategyBuilder={build:function(a,b){var c=Pusher.Util.extend({},e,b);return d(a,c)[1].strategy}}}).call(this);
    (function(){Pusher.Protocol={decodeMessage:function(b){try{var c=JSON.parse(b.data);if("string"===typeof c.data)try{c.data=JSON.parse(c.data)}catch(a){if(!(a instanceof SyntaxError))throw a;}return c}catch(d){throw{type:"MessageParseError",error:d,data:b.data};}},encodeMessage:function(b){return JSON.stringify(b)},processHandshake:function(b){b=this.decodeMessage(b);if("pusher:connection_established"===b.event){if(!b.data.activity_timeout)throw"No activity timeout specified in handshake";return{action:"connected",
    id:b.data.socket_id,activityTimeout:1E3*b.data.activity_timeout}}if("pusher:error"===b.event)return{action:this.getCloseAction(b.data),error:this.getCloseError(b.data)};throw"Invalid handshake";},getCloseAction:function(b){return 4E3>b.code?1002<=b.code&&1004>=b.code?"backoff":null:4E3===b.code?"ssl_only":4100>b.code?"refused":4200>b.code?"backoff":4300>b.code?"retry":"refused"},getCloseError:function(b){return 1E3!==b.code&&1001!==b.code?{type:"PusherError",data:{code:b.code,message:b.reason||b.message}}:
    null}}}).call(this);
    (function(){function b(a,b){Pusher.EventsDispatcher.call(this);this.id=a;this.transport=b;this.activityTimeout=b.activityTimeout;this.bindListeners()}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.handlesActivityChecks=function(){return this.transport.handlesActivityChecks()};c.send=function(a){return this.transport.send(a)};c.send_event=function(a,b,c){a={event:a,data:b};c&&(a.channel=c);Pusher.debug("Event sent",a);return this.send(Pusher.Protocol.encodeMessage(a))};c.ping=
    function(){this.transport.supportsPing()?this.transport.ping():this.send_event("pusher:ping",{})};c.close=function(){this.transport.close()};c.bindListeners=function(){var a=this,b={message:function(b){var c;try{c=Pusher.Protocol.decodeMessage(b)}catch(d){a.emit("error",{type:"MessageParseError",error:d,data:b.data})}if(void 0!==c){Pusher.debug("Event recd",c);switch(c.event){case "pusher:error":a.emit("error",{type:"PusherError",data:c.data});break;case "pusher:ping":a.emit("ping");break;case "pusher:pong":a.emit("pong")}a.emit("message",
    c)}},activity:function(){a.emit("activity")},error:function(b){a.emit("error",{type:"WebSocketError",error:b})},closed:function(b){c();b&&b.code&&a.handleCloseEvent(b);a.transport=null;a.emit("closed")}},c=function(){Pusher.Util.objectApply(b,function(b,c){a.transport.unbind(c,b)})};Pusher.Util.objectApply(b,function(b,c){a.transport.bind(c,b)})};c.handleCloseEvent=function(a){var b=Pusher.Protocol.getCloseAction(a);(a=Pusher.Protocol.getCloseError(a))&&this.emit("error",a);b&&this.emit(b)};Pusher.Connection=
    b}).call(this);
    (function(){function b(a,b){this.transport=a;this.callback=b;this.bindListeners()}var c=b.prototype;c.close=function(){this.unbindListeners();this.transport.close()};c.bindListeners=function(){var a=this;a.onMessage=function(b){a.unbindListeners();try{var c=Pusher.Protocol.processHandshake(b);"connected"===c.action?a.finish("connected",{connection:new Pusher.Connection(c.id,a.transport),activityTimeout:c.activityTimeout}):(a.finish(c.action,{error:c.error}),a.transport.close())}catch(f){a.finish("error",{error:f}),
    a.transport.close()}};a.onClosed=function(b){a.unbindListeners();var c=Pusher.Protocol.getCloseAction(b)||"backoff";b=Pusher.Protocol.getCloseError(b);a.finish(c,{error:b})};a.transport.bind("message",a.onMessage);a.transport.bind("closed",a.onClosed)};c.unbindListeners=function(){this.transport.unbind("message",this.onMessage);this.transport.unbind("closed",this.onClosed)};c.finish=function(a,b){this.callback(Pusher.Util.extend({transport:this.transport,action:a},b))};Pusher.Handshake=b}).call(this);
    (function(){function b(a,b){Pusher.EventsDispatcher.call(this);this.key=a;this.options=b||{};this.state="initialized";this.connection=null;this.encrypted=!!b.encrypted;this.timeline=this.options.timeline;this.connectionCallbacks=this.buildConnectionCallbacks();this.errorCallbacks=this.buildErrorCallbacks();this.handshakeCallbacks=this.buildHandshakeCallbacks(this.errorCallbacks);var c=this;Pusher.Network.bind("online",function(){c.timeline.info({netinfo:"online"});("connecting"===c.state||"unavailable"===
    c.state)&&c.retryIn(0)});Pusher.Network.bind("offline",function(){c.timeline.info({netinfo:"offline"});"connected"===c.state&&c.sendActivityCheck()});this.updateStrategy()}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.connect=function(){!this.connection&&!this.runner&&(this.strategy.isSupported()?(this.updateState("connecting"),this.startConnecting(),this.setUnavailableTimer()):this.updateState("failed"))};c.send=function(a){return this.connection?this.connection.send(a):
    !1};c.send_event=function(a,b,c){return this.connection?this.connection.send_event(a,b,c):!1};c.disconnect=function(){this.disconnectInternally();this.updateState("disconnected")};c.isEncrypted=function(){return this.encrypted};c.startConnecting=function(){var a=this,b=function(c,f){c?a.runner=a.strategy.connect(0,b):"error"===f.action?(a.emit("error",{type:"HandshakeError",error:f.error}),a.timeline.error({handshakeError:f.error})):(a.abortConnecting(),a.handshakeCallbacks[f.action](f))};a.runner=
    a.strategy.connect(0,b)};c.abortConnecting=function(){this.runner&&(this.runner.abort(),this.runner=null)};c.disconnectInternally=function(){this.abortConnecting();this.clearRetryTimer();this.clearUnavailableTimer();this.stopActivityCheck();this.connection&&this.abandonConnection().close()};c.updateStrategy=function(){this.strategy=this.options.getStrategy({key:this.key,timeline:this.timeline,encrypted:this.encrypted})};c.retryIn=function(a){var b=this;b.timeline.info({action:"retry",delay:a});0<
    a&&b.emit("connecting_in",Math.round(a/1E3));b.retryTimer=new Pusher.Timer(a||0,function(){b.disconnectInternally();b.connect()})};c.clearRetryTimer=function(){this.retryTimer&&(this.retryTimer.ensureAborted(),this.retryTimer=null)};c.setUnavailableTimer=function(){var a=this;a.unavailableTimer=new Pusher.Timer(a.options.unavailableTimeout,function(){a.updateState("unavailable")})};c.clearUnavailableTimer=function(){this.unavailableTimer&&this.unavailableTimer.ensureAborted()};c.sendActivityCheck=
    function(){var a=this;a.stopActivityCheck();a.connection.ping();a.activityTimer=new Pusher.Timer(a.options.pongTimeout,function(){a.timeline.error({pong_timed_out:a.options.pongTimeout});a.retryIn(0)})};c.resetActivityCheck=function(){var a=this;a.stopActivityCheck();a.connection.handlesActivityChecks()||(a.activityTimer=new Pusher.Timer(a.activityTimeout,function(){a.sendActivityCheck()}))};c.stopActivityCheck=function(){this.activityTimer&&this.activityTimer.ensureAborted()};c.buildConnectionCallbacks=
    function(){var a=this;return{message:function(b){a.resetActivityCheck();a.emit("message",b)},ping:function(){a.send_event("pusher:pong",{})},activity:function(){a.resetActivityCheck()},error:function(b){a.emit("error",{type:"WebSocketError",error:b})},closed:function(){a.abandonConnection();a.shouldRetry()&&a.retryIn(1E3)}}};c.buildHandshakeCallbacks=function(a){var b=this;return Pusher.Util.extend({},a,{connected:function(a){b.activityTimeout=Math.min(b.options.activityTimeout,a.activityTimeout,
    a.connection.activityTimeout||Infinity);b.clearUnavailableTimer();b.setConnection(a.connection);b.socket_id=b.connection.id;b.updateState("connected",{socket_id:b.socket_id})}})};c.buildErrorCallbacks=function(){function a(a){return function(c){c.error&&b.emit("error",{type:"WebSocketError",error:c.error});a(c)}}var b=this;return{ssl_only:a(function(){b.encrypted=!0;b.updateStrategy();b.retryIn(0)}),refused:a(function(){b.disconnect()}),backoff:a(function(){b.retryIn(1E3)}),retry:a(function(){b.retryIn(0)})}};
    c.setConnection=function(a){this.connection=a;for(var b in this.connectionCallbacks)this.connection.bind(b,this.connectionCallbacks[b]);this.resetActivityCheck()};c.abandonConnection=function(){if(this.connection){for(var a in this.connectionCallbacks)this.connection.unbind(a,this.connectionCallbacks[a]);a=this.connection;this.connection=null;return a}};c.updateState=function(a,b){var c=this.state;this.state=a;c!==a&&(Pusher.debug("State changed",c+" -> "+a),this.timeline.info({state:a,params:b}),
    this.emit("state_change",{previous:c,current:a}),this.emit(a,b))};c.shouldRetry=function(){return"connecting"===this.state||"connected"===this.state};Pusher.ConnectionManager=b}).call(this);
    (function(){function b(){Pusher.EventsDispatcher.call(this);var b=this;void 0!==window.addEventListener&&(window.addEventListener("online",function(){b.emit("online")},!1),window.addEventListener("offline",function(){b.emit("offline")},!1))}Pusher.Util.extend(b.prototype,Pusher.EventsDispatcher.prototype);b.prototype.isOnline=function(){return void 0===window.navigator.onLine?!0:window.navigator.onLine};Pusher.NetInfo=b;Pusher.Network=new b}).call(this);
    (function(){function b(){this.reset()}var c=b.prototype;c.get=function(a){return Object.prototype.hasOwnProperty.call(this.members,a)?{id:a,info:this.members[a]}:null};c.each=function(a){var b=this;Pusher.Util.objectApply(b.members,function(c,f){a(b.get(f))})};c.setMyID=function(a){this.myID=a};c.onSubscription=function(a){this.members=a.presence.hash;this.count=a.presence.count;this.me=this.get(this.myID)};c.addMember=function(a){null===this.get(a.user_id)&&this.count++;this.members[a.user_id]=a.user_info;
    return this.get(a.user_id)};c.removeMember=function(a){var b=this.get(a.user_id);b&&(delete this.members[a.user_id],this.count--);return b};c.reset=function(){this.members={};this.count=0;this.me=this.myID=null};Pusher.Members=b}).call(this);
    (function(){function b(a,b){Pusher.EventsDispatcher.call(this,function(b,c){Pusher.debug("No callbacks on "+a+" for "+b)});this.name=a;this.pusher=b;this.subscribed=!1}var c=b.prototype;Pusher.Util.extend(c,Pusher.EventsDispatcher.prototype);c.authorize=function(a,b){return b(!1,{})};c.trigger=function(a,b){if(0!==a.indexOf("client-"))throw new Pusher.Errors.BadEventName("Event '"+a+"' does not start with 'client-'");return this.pusher.send_event(a,b,this.name)};c.disconnect=function(){this.subscribed=
    !1};c.handleEvent=function(a,b){0===a.indexOf("pusher_internal:")?"pusher_internal:subscription_succeeded"===a&&(this.subscribed=!0,this.emit("pusher:subscription_succeeded",b)):this.emit(a,b)};c.subscribe=function(){var a=this;a.authorize(a.pusher.connection.socket_id,function(b,c){b?a.handleEvent("pusher:subscription_error",c):a.pusher.send_event("pusher:subscribe",{auth:c.auth,channel_data:c.channel_data,channel:a.name})})};c.unsubscribe=function(){this.pusher.send_event("pusher:unsubscribe",{channel:this.name})};
    Pusher.Channel=b}).call(this);(function(){function b(a,b){Pusher.Channel.call(this,a,b)}var c=b.prototype;Pusher.Util.extend(c,Pusher.Channel.prototype);c.authorize=function(a,b){return(new Pusher.Channel.Authorizer(this,this.pusher.config)).authorize(a,b)};Pusher.PrivateChannel=b}).call(this);
    (function(){function b(a,b){Pusher.PrivateChannel.call(this,a,b);this.members=new Pusher.Members}var c=b.prototype;Pusher.Util.extend(c,Pusher.PrivateChannel.prototype);c.authorize=function(a,b){var c=this;Pusher.PrivateChannel.prototype.authorize.call(c,a,function(a,e){if(!a){if(void 0===e.channel_data){Pusher.warn("Invalid auth response for channel '"+c.name+"', expected 'channel_data' field");b("Invalid auth response");return}var g=JSON.parse(e.channel_data);c.members.setMyID(g.user_id)}b(a,e)})};
    c.handleEvent=function(a,b){switch(a){case "pusher_internal:subscription_succeeded":this.members.onSubscription(b);this.subscribed=!0;this.emit("pusher:subscription_succeeded",this.members);break;case "pusher_internal:member_added":var c=this.members.addMember(b);this.emit("pusher:member_added",c);break;case "pusher_internal:member_removed":(c=this.members.removeMember(b))&&this.emit("pusher:member_removed",c);break;default:Pusher.PrivateChannel.prototype.handleEvent.call(this,a,b)}};c.disconnect=
    function(){this.members.reset();Pusher.PrivateChannel.prototype.disconnect.call(this)};Pusher.PresenceChannel=b}).call(this);
    (function(){function b(){this.channels={}}var c=b.prototype;c.add=function(a,b){if(!this.channels[a]){var c=this.channels,f;f=0===a.indexOf("private-")?new Pusher.PrivateChannel(a,b):0===a.indexOf("presence-")?new Pusher.PresenceChannel(a,b):new Pusher.Channel(a,b);c[a]=f}return this.channels[a]};c.all=function(a){return Pusher.Util.values(this.channels)};c.find=function(a){return this.channels[a]};c.remove=function(a){var b=this.channels[a];delete this.channels[a];return b};c.disconnect=function(){Pusher.Util.objectApply(this.channels,
    function(a){a.disconnect()})};Pusher.Channels=b}).call(this);
    (function(){Pusher.Channel.Authorizer=function(b,a){this.channel=b;this.type=a.authTransport;this.options=a;this.authOptions=(a||{}).auth||{}};Pusher.Channel.Authorizer.prototype={composeQuery:function(b){b="&socket_id="+encodeURIComponent(b)+"&channel_name="+encodeURIComponent(this.channel.name);for(var a in this.authOptions.params)b+="&"+encodeURIComponent(a)+"="+encodeURIComponent(this.authOptions.params[a]);return b},authorize:function(b,a){return Pusher.authorizers[this.type].call(this,b,a)}};
    var b=1;Pusher.auth_callbacks={};Pusher.authorizers={ajax:function(b,a){var d;d=Pusher.XHR?new Pusher.XHR:window.XMLHttpRequest?new window.XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP");d.open("POST",this.options.authEndpoint,!0);d.setRequestHeader("Content-Type","application/x-www-form-urlencoded");for(var h in this.authOptions.headers)d.setRequestHeader(h,this.authOptions.headers[h]);d.onreadystatechange=function(){if(4===d.readyState)if(200===d.status){var b,c=!1;try{b=JSON.parse(d.responseText),
    c=!0}catch(g){a(!0,"JSON returned from webapp was invalid, yet status code was 200. Data was: "+d.responseText)}c&&a(!1,b)}else Pusher.warn("Couldn't get auth info from your webapp",d.status),a(!0,d.status)};d.send(this.composeQuery(b));return d},jsonp:function(c,a){void 0!==this.authOptions.headers&&Pusher.warn("Warn","To send headers with the auth request, you must use AJAX, rather than JSONP.");var d=b.toString();b++;var h=Pusher.Util.getDocument(),f=h.createElement("script");Pusher.auth_callbacks[d]=
    function(b){a(!1,b)};f.src=this.options.authEndpoint+"?callback="+encodeURIComponent("Pusher.auth_callbacks['"+d+"']")+this.composeQuery(c);d=h.getElementsByTagName("head")[0]||h.documentElement;d.insertBefore(f,d.firstChild)}}}).call(this);

    //reroute log messages to console
    Pusher.log = function(message) {
      if (window.console && window.console.info && window.location.search.indexOf('debugger=true') >= 0) { window.console.info(message); }
    };
    return Pusher;
}));

define('ic',[
  "jquery/nyt",
  "underscore/nyt",
  "pourover",
  "pusher"],
function($,_,PourOver,Pusher){

IC = {}

// Copied from Backbone//{{{
function md5cycle(x, k) {
var a = x[0], b = x[1], c = x[2], d = x[3];

a = ff(a, b, c, d, k[0], 7, -680876936);
d = ff(d, a, b, c, k[1], 12, -389564586);
c = ff(c, d, a, b, k[2], 17,  606105819);
b = ff(b, c, d, a, k[3], 22, -1044525330);
a = ff(a, b, c, d, k[4], 7, -176418897);
d = ff(d, a, b, c, k[5], 12,  1200080426);
c = ff(c, d, a, b, k[6], 17, -1473231341);
b = ff(b, c, d, a, k[7], 22, -45705983);
a = ff(a, b, c, d, k[8], 7,  1770035416);
d = ff(d, a, b, c, k[9], 12, -1958414417);
c = ff(c, d, a, b, k[10], 17, -42063);
b = ff(b, c, d, a, k[11], 22, -1990404162);
a = ff(a, b, c, d, k[12], 7,  1804603682);
d = ff(d, a, b, c, k[13], 12, -40341101);
c = ff(c, d, a, b, k[14], 17, -1502002290);
b = ff(b, c, d, a, k[15], 22,  1236535329);

a = gg(a, b, c, d, k[1], 5, -165796510);
d = gg(d, a, b, c, k[6], 9, -1069501632);
c = gg(c, d, a, b, k[11], 14,  643717713);
b = gg(b, c, d, a, k[0], 20, -373897302);
a = gg(a, b, c, d, k[5], 5, -701558691);
d = gg(d, a, b, c, k[10], 9,  38016083);
c = gg(c, d, a, b, k[15], 14, -660478335);
b = gg(b, c, d, a, k[4], 20, -405537848);
a = gg(a, b, c, d, k[9], 5,  568446438);
d = gg(d, a, b, c, k[14], 9, -1019803690);
c = gg(c, d, a, b, k[3], 14, -187363961);
b = gg(b, c, d, a, k[8], 20,  1163531501);
a = gg(a, b, c, d, k[13], 5, -1444681467);
d = gg(d, a, b, c, k[2], 9, -51403784);
c = gg(c, d, a, b, k[7], 14,  1735328473);
b = gg(b, c, d, a, k[12], 20, -1926607734);

a = hh(a, b, c, d, k[5], 4, -378558);
d = hh(d, a, b, c, k[8], 11, -2022574463);
c = hh(c, d, a, b, k[11], 16,  1839030562);
b = hh(b, c, d, a, k[14], 23, -35309556);
a = hh(a, b, c, d, k[1], 4, -1530992060);
d = hh(d, a, b, c, k[4], 11,  1272893353);
c = hh(c, d, a, b, k[7], 16, -155497632);
b = hh(b, c, d, a, k[10], 23, -1094730640);
a = hh(a, b, c, d, k[13], 4,  681279174);
d = hh(d, a, b, c, k[0], 11, -358537222);
c = hh(c, d, a, b, k[3], 16, -722521979);
b = hh(b, c, d, a, k[6], 23,  76029189);
a = hh(a, b, c, d, k[9], 4, -640364487);
d = hh(d, a, b, c, k[12], 11, -421815835);
c = hh(c, d, a, b, k[15], 16,  530742520);
b = hh(b, c, d, a, k[2], 23, -995338651);

a = ii(a, b, c, d, k[0], 6, -198630844);
d = ii(d, a, b, c, k[7], 10,  1126891415);
c = ii(c, d, a, b, k[14], 15, -1416354905);
b = ii(b, c, d, a, k[5], 21, -57434055);
a = ii(a, b, c, d, k[12], 6,  1700485571);
d = ii(d, a, b, c, k[3], 10, -1894986606);
c = ii(c, d, a, b, k[10], 15, -1051523);
b = ii(b, c, d, a, k[1], 21, -2054922799);
a = ii(a, b, c, d, k[8], 6,  1873313359);
d = ii(d, a, b, c, k[15], 10, -30611744);
c = ii(c, d, a, b, k[6], 15, -1560198380);
b = ii(b, c, d, a, k[13], 21,  1309151649);
a = ii(a, b, c, d, k[4], 6, -145523070);
d = ii(d, a, b, c, k[11], 10, -1120210379);
c = ii(c, d, a, b, k[2], 15,  718787259);
b = ii(b, c, d, a, k[9], 21, -343485551);

x[0] = add32(a, x[0]);
x[1] = add32(b, x[1]);
x[2] = add32(c, x[2]);
x[3] = add32(d, x[3]);

}

function cmn(q, a, b, x, s, t) {
a = add32(add32(a, q), add32(x, t));
return add32((a << s) | (a >>> (32 - s)), b);
}

function ff(a, b, c, d, x, s, t) {
return cmn((b & c) | ((~b) & d), a, b, x, s, t);
}

function gg(a, b, c, d, x, s, t) {
return cmn((b & d) | (c & (~d)), a, b, x, s, t);
}

function hh(a, b, c, d, x, s, t) {
return cmn(b ^ c ^ d, a, b, x, s, t);
}

function ii(a, b, c, d, x, s, t) {
return cmn(c ^ (b | (~d)), a, b, x, s, t);
}

function md51(s) {
txt = '';
var n = s.length,
state = [1732584193, -271733879, -1732584194, 271733878], i;
for (i=64; i<=s.length; i+=64) {
md5cycle(state, md5blk(s.substring(i-64, i)));
}
s = s.substring(i-64);
var tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
for (i=0; i<s.length; i++)
tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);
tail[i>>2] |= 0x80 << ((i%4) << 3);
if (i > 55) {
md5cycle(state, tail);
for (i=0; i<16; i++) tail[i] = 0;
}
tail[14] = n*8;
md5cycle(state, tail);
return state;
}

/* there needs to be support for Unicode here,
 * unless we pretend that we can redefine the MD-5
 * algorithm for multi-byte characters (perhaps
 * by adding every four 16-bit characters and
 * shortening the sum to 32 bits). Otherwise
 * I suggest performing MD-5 as if every character
 * was two bytes--e.g., 0040 0025 = @%--but then
 * how will an ordinary MD-5 sum be matched?
 * There is no way to standardize text to something
 * like UTF-8 before transformation; speed cost is
 * utterly prohibitive. The JavaScript standard
 * itself needs to look at this: it should start
 * providing access to strings as preformed UTF-8
 * 8-bit unsigned value arrays.
 */
function md5blk(s) { /* I figured global was faster.   */
var md5blks = [], i; /* Andy King said do it this way. */
for (i=0; i<64; i+=4) {
md5blks[i>>2] = s.charCodeAt(i)
+ (s.charCodeAt(i+1) << 8)
+ (s.charCodeAt(i+2) << 16)
+ (s.charCodeAt(i+3) << 24);
}
return md5blks;
}

var hex_chr = '0123456789abcdef'.split('');

function rhex(n)
{
var s='', j=0;
for(; j<4; j++)
s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]
+ hex_chr[(n >> (j * 8)) & 0x0F];
return s;
}

function hex(x) {
for (var i=0; i<x.length; i++)
x[i] = rhex(x[i]);
return x.join('');
}

function md5(s) {
return hex(md51(s));
}

/* this function is much faster,
so if possible we use it. Some IEs
are the only ones I know of that
need the idiotic second function,
generated by an if clause.  */

function add32(a, b) {
return (a + b) & 0xFFFFFFFF;
}

if (md5('hello') != '5d41402abc4b2a76b9719d911017c592') {
function add32(x, y) {
var lsw = (x & 0xFFFF) + (y & 0xFFFF),
msw = (x >> 16) + (y >> 16) + (lsw >> 16);
return (msw << 16) | (lsw & 0xFFFF);
}
}
var array = [];
var push = array.push;
var slice = array.slice;
var splice = array.splice;
var Events = IC.Events = {

// Bind an event to a `callback` function. Passing `"all"` will bind
// the callback to all events fired.
on: function(name, callback, context) {
  if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
  this._events || (this._events = {});
  var events = this._events[name] || (this._events[name] = []);
  events.push({callback: callback, context: context, ctx: context || this});
  return this;
},

// Bind an event to only be triggered a single time. After the first time
// the callback is invoked, it will be removed.
once: function(name, callback, context) {
  if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
  var self = this;
  var once = _.once(function() {
    self.off(name, once);
    callback.apply(this, arguments);
  });
  once._callback = callback;
  return this.on(name, once, context);
},

// Remove one or many callbacks. If `context` is null, removes all
// callbacks with that function. If `callback` is null, removes all
// callbacks for the event. If `name` is null, removes all bound
// callbacks for all events.
off: function(name, callback, context) {
  var retain, ev, events, names, i, l, j, k;
  if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
  if (!name && !callback && !context) {
    this._events = void 0;
    return this;
  }
  names = name ? [name] : _.keys(this._events);
  for (i = 0, l = names.length; i < l; i++) {
    name = names[i];
    if (events = this._events[name]) {
      this._events[name] = retain = [];
      if (callback || context) {
        for (j = 0, k = events.length; j < k; j++) {
          ev = events[j];
          if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
              (context && context !== ev.context)) {
            retain.push(ev);
          }
        }
      }
      if (!retain.length) delete this._events[name];
    }
  }

  return this;
},

// Trigger one or many events, firing all bound callbacks. Callbacks are
// passed the same arguments as `trigger` is, apart from the event name
// (unless you're listening on `"all"`, which will cause your callback to
// receive the true name of the event as the first argument).
trigger: function(name) {
  if (!this._events) return this;
  var args = slice.call(arguments, 1);
  if (!eventsApi(this, 'trigger', name, args)) return this;
  var events = this._events[name];
  var allEvents = this._events.all;
  if (events) triggerEvents(events, args);
  if (allEvents) triggerEvents(allEvents, arguments);
  return this;
},

// Tell this object to stop listening to either specific events ... or
// to every object it's currently listening to.
stopListening: function(obj, name, callback) {
  var listeningTo = this._listeningTo;
  if (!listeningTo) return this;
  var remove = !name && !callback;
  if (!callback && typeof name === 'object') callback = this;
  if (obj) (listeningTo = {})[obj._listenId] = obj;
  for (var id in listeningTo) {
    obj = listeningTo[id];
    obj.off(name, callback, this);
    if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
  }
  return this;
}

};

// Regular expression used to split event strings.
var eventSplitter = /\s+/;

// Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.
var eventsApi = function(obj, action, name, rest) {
if (!name) return true;

// Handle event maps.
if (typeof name === 'object') {
  for (var key in name) {
    obj[action].apply(obj, [key, name[key]].concat(rest));
  }
  return false;
}

// Handle space separated event names.
if (eventSplitter.test(name)) {
  var names = name.split(eventSplitter);
  for (var i = 0, l = names.length; i < l; i++) {
    obj[action].apply(obj, [names[i]].concat(rest));
  }
  return false;
}

return true;
};

var triggerEvents = function(events, args) {
var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
switch (args.length) {
  case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
  case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
  case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
  case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
  default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
}
};

var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.
_.each(listenMethods, function(implementation, method) {
Events[method] = function(obj, name, callback) {
  var listeningTo = this._listeningTo || (this._listeningTo = {});
  var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
  listeningTo[id] = obj;
  if (!callback && typeof name === 'object') callback = this;
  obj[implementation](name, callback, this);
  return this;
};
});

// Aliases for backwards compatibility.
Events.bind   = Events.on;
Events.unbind = Events.off;//}}}

/**
 * An Invisible Cities broker.
 *
 * @class
 * @param {object} options An initializing options hash for the Broker.
 */
IC.Broker = function(options){
    this.subscriptions = {};
    this.consumers = [];

    // Endpoints
    this.load_url             = options.load_url;
    this.dynamic_fallback_url = options.dynamic_fallback_url;

    // Connection options
    if ( typeof options.websocket_on != 'undefined' ) {
      this.websocket_on = options.websocket_on;
    } else {
      this.websocket_on = true;
    }

    if ( typeof options.dynamic_fallback_on != 'undefined' ) {
      this.dynamic_fallback_on = options.dynamic_fallback_on;
    } else {
      this.dynamic_fallback_on = true;
    }

    this.polling_on          = options.polling_on || false;

    this.environment = options.environment || 'production';

    // If a pusher key hasn't been set, set it to the key for Invisible City.
    if ( ! options.pusher_config || ! options.pusher_config.key ) {
      if ( this.environment === 'production' ) {
        this.pusher_config = {
          key: 'a4794403fbe72ed0b016'
        };
      } else {
        this.pusher_config = {
          key: 'acc76abbc0158fa7511c'
        };
      }
    }

    if(this.websocket_on && this.polling_on) {
      throw "Invalid configuration; cannot have the websocket and polling enabled simultaneously."
    }
    window._IC_BROKER = this;
}

_.extend(IC.Broker.prototype,IC.Events,{
    poll_time: 15000,
    poll_backoff_c: 0,
    poll_time_override: false,

    /**
     * Request all messages from the given endpoint.
     */
    getLoadPack: function(first_run){
        var initial_load_url;
        if(typeof(first_run) === "undefined"){
            first_run = false;
        }

        if (this.load_url.match(/.json$/)) {
            initial_load_url = this.load_url;
        } else {
            initial_load_url = this.load_url + "bundles/" + this.md5encodeSubscriptionSet() + ".json";
        }

        if(initial_load_url){
            $.ajax(initial_load_url,
                {
                    timeout: 3000
                }
            ).done(_.bind(function(msg){
                console.info("Static polling succeeded");
                this.loadPack(msg,true);
                this.load_promise.resolve(msg);
                if(! this.poll_time_override && this.poll_backoff_c > 0){
                    console.warn("Resetting poll time")
                    this.poll_backoff_c = 0;
                    this.stopPolling();
                    this.startPolling();
                }
            },this)).fail(_.bind(function(msg){
                if(first_run){
                    console.warn("Static polling failed. Falling back to dynamic",msg);
                    if(this.dynamic_fallback_on){
                        this.getLoadPackDyn();
                    } else {
                        this.load_promise.reject();
                    }
                } else {
                    this.load_promise.reject();
                }
            },this))
            this.load_promise = $.Deferred();
        } else {
            this.load_promise = $.Deferred();
            this.load_promise.resolve();
        }
    },
    /**
     * Request all messages from the given "dynamic" endpoint.
     *
     * This is failover for the IC server in case the pretty URL isn't working.
     */
    getLoadPackDyn: function(){
        var full_url = this.dynamic_fallback_url +"?q=" + this.encodeSubscriptionSet();
        if(this.dynamic_fallback_url){
            return $.ajax(full_url,
                {
                    timeout: 5000
                }
            ).done(_.bind(function(msg){
                this.loadPack(msg,true);
                this.load_promise.resolve(msg);
            },this));
        } else {
            return $.Deferred().resolve();
        }
    },
    finalize: function(){
        this.getLoadPack(! this.loaded_once)
        this.load_promise.done(_.bind(function(msg){
            this.loaded_once = true;
            this.pack_sha = msg.sha;
            _(this.consumers).each(function(c){
                c.trigger("first-load");
            });
            if(this.websocket_on){
                this.startWebsocket();
            } else if(this.polling_on){
                this.startPolling();
            } else {
                return;
            }
        },this));
    },
    resetBroker: function(){
        console.warn("Resetting Broker");
        if(this.poll){
            clearInterval(this.poll);
        }
        if(this.channel){
            this.stopWebsocket();
        }
        setTimeout(_.bind(function(){
            this.finalize();
        },this),5000)
    },
    switchToPolling: function(){
      if(this.polling_on){
          return;
      } else {
        console.warn("Switching to polling");
        this.stopWebsocket();
        this.polling_on = true;
        setTimeout(_.bind(function(){
            this.finalize();
        },this),5000)
      }
    },
    startPolling: function(){
        var random_time = Math.round(Math.random() * 1000),
            poll_time = this.poll_time + this.poll_backoff_c + random_time;
        this.polling_on = true;
        if(this.poll){
            clearInterval(this.poll);
        }
        this.poll = setInterval(_.bind(function(){
             console.info("Polling for new data on a",poll_time,"ms interval");
             this.getLoadPack()
             this.load_promise.fail(_.bind(function(){
                this.stopPolling();
                console.warn("Polling failed, extending poll interval");
                this.poll_backoff_c = this.poll_backoff_c ? this.poll_backoff_c * 2 : 2000;
                this.startPolling();
             },this));
        },this),poll_time);
    },
    stopPolling: function(){
        this.polling_on = false;
        if(this.poll){
            clearInterval(this.poll);
        }
    },
    startWebsocket: function(){
        var pusher;
        pusher = new Pusher(this.pusher_config.key, this.pusher_config);

        var channel = pusher.subscribe(this.pack_sha);
        this.pusher = pusher;
        this.channel = channel;
        channel.bind('message', _.bind(function(data) {
          console.info("Message received:",data);
          this.loadPack(data,false);
        },this));
    },
    stopWebsocket: function(){
        this.channel.unbind('message');
        this.pusher.disconnect();
    },
    registerConsumer: function(consumer){
        _(consumer.subscriptions).each(_.bind(function(v){
            // Sets up a new subscription to a stream, if the broker hasn't seen this stream before
            if(!this.subscriptions[v]){
                this.subscriptions[v] = [];
            }

            var current_stream_set = this.subscriptions[v];

            // De-dupes consumer so you can register twice if subs change
            if(! _.find(current_stream_set,function(c){return c.name === consumer.name})){
                current_stream_set.push(consumer);
            }


        },this));
        if(! _(this.consumers).any(function(c){return c.name == consumer.name})){
            this.consumers.push(consumer);
        }
    },
    generateSubscriptionSet: function(){
        var sorted_messages = _(this.subscriptions).keys().sort(function(a,b){return a < b ? -1 : a === b ? 0 : 1});
        return sorted_messages;
    },
    encodeSubscriptionSet: function(){
        var subscription_set = this.generateSubscriptionSet();
        return encodeURIComponent(JSON.stringify(subscription_set));
    },
    md5encodeSubscriptionSet: function(){
        var plaintext = JSON.stringify(this.generateSubscriptionSet());
        return md5(plaintext);
    },
    /**
     * Deliver messages for a stream to all the stream's subscribers.
     */
    deliverMessages: function(stream,messages,first_load){
        var stream_subscribers = this.subscriptions[stream];
        if(! stream_subscribers){return}

        _(stream_subscribers).each(function(s){
            if(first_load){
                s.handleFirstLoad(messages);
            } else {
                s.handleMessages(messages);
            }
        })
    },
    checkTimebox: function(timebox){
        console.log("CHECK TIMEBOX")
        if(timebox !== this.initial_timebox + 1){
            console.log("MISSED TIMEBOX", timebox, this.initial_timebox)
            var diff = timebox - this.initial_timebox;
            if(diff > 5){
                throw "Timebox diff too great: " + diff;
                return;
            } else if (diff < 0){
                throw "Negative timebox differential";
                return;
            }
            for(i = 1; i < diff; i++){
                var missed_timebox = this.initial_timebox + i;
                this.getTimebox(missed_timebox);
            }
        }
    },
    getTimebox: function(timebox){
      var timebox_url = this.load_url + "timeboxes/" + this.md5encodeSubscriptionSet() + "/" + timebox + ".json";
        $.ajax(timebox_url,{timeout: 3000})
         .done(_.bind(function(data){
            this.loadPack(data);
         },this))
    },
    /**
     * Given a pack of received messages, cycle through them and deliver messages
     * to consumers.
     */
    loadPack: function(msg,first_load){
        var encoding = msg.encoding,
            saturation_promise = $.Deferred();

        if(encoding === "pointer"){
            $.ajax(this.load_url + msg.pointer_path, {timeout: 3000}
            ).done(_.bind(function(m){
                saturation_promise.resolve(m);
            },this));
        } else {
            saturation_promise.resolve(msg);
        }

        saturation_promise.done(_.bind(function(full_msg){
            if(first_load){
                this.initial_timebox = full_msg.timebox;
                this.check_next_timebox = true;
            } else {
                if(this.check_next_timebox){
                    this.check_next_timebox = false;
                    this.checkTimebox(full_msg.timebox)
                }
            }
            _(full_msg.contents).each(_.bind(function(messages,stream){
                console.debug("LOAD",messages,stream)
                this.deliverMessages(stream,messages,first_load);
            },this));
        },this));
    }
})

// Create a consumer with a list of subscriptions, stream_names
Consumer = IC.Consumer = function(subscriptions,name){
    if(typeof(name) === "undefined"){
        name = "consumer_" + String(Math.random()).slice(2);
    }
    this.name = name;

    this.setupSubs.call(this,subscriptions);
    this.initialize.apply(this, arguments);
}

_.extend(Consumer.prototype,IC.Events,{
    initialize: function(){},
    setupSubs: function(subs){
        this.subscriptions = [];
        if(typeof(subs) === "string"){
            // Consumer is subscribing to all messages from a particular stream
            this.subscriptions = [subs];
        } else if (_.isArray(subs)){
            this.subscriptions = subs;
        } else if (typeof(subs) === "undefined") {
            // Consumer is not subscribing to any streams or messages
        } else {
            throw "Invalid subscription: " + JSON.stringify(subs);
        }
    },
    register: function(broker){
        broker.registerConsumer(this);
        this.trigger("post-register");
    },
    handleFirstLoad: function(){
        throw "You must implement handleFirstLoad for custom consumers"
    },
    handleMessages: function(){
        throw "You must implement handleMessages for custom consumers"
    },
    render: function(){}
})

IC.extend = function(protoProps, staticProps) {//{{{
  var parent = this;
  var child;

  // The constructor function for the new subclass is either defined by you
  // (the "constructor" property in your `extend` definition), or defaulted
  // by us to simply call the parent's constructor.
  if (protoProps && _.has(protoProps, 'constructor')) {
    child = protoProps.constructor;
  } else {
    child = function() {
      return parent.apply(this, arguments);
    };
  }

  // Add static properties to the constructor function, if supplied.
  _.extend(child, parent, staticProps);

  // Set the prototype chain to inherit from `parent`, without calling
  // `parent`'s constructor function.
  var Surrogate = function() {
      this.constructor = child;
    };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate;

  // Add prototype properties (instance properties) to the subclass,
  // if supplied.
  if (protoProps) _.extend(child.prototype, protoProps);

  // Set a convenience property in case the parent's prototype is needed
  // later.
  child.__super__ = parent.prototype;

  return child;
};

IC.Consumer.extend = IC.extend//}}}

IC.SingletonConsumer = IC.Consumer.extend({
    initialize: function(subscriptions){
        this.value = 0;
        this.order_stamp = 0;
        this.stream_name = subscriptions[0];
    },
    hasChanged: function(attr){
        if (! this.last_value || _.isEmpty(this.last_value)) { return false; }
        var levels = attr.split("."),
            value = this.value,
            last_value = this.last_value,
            m,index;
        _(levels).each(function(l){
            if(m = l.match(/(.+?)\[(.+?)\]/)){
                index = m[2];
                value = value[m[1]][index];
                last_value = last_value[m[1]][index];
            } else {
                value = value[l];
                last_value = last_value[l];
            }
        });
        return value !== last_value;
    },
    handleFirstLoad: function(messages){
        this.last_value = {};
        if(messages.length > 0){
            this.value = messages[0];
            this.version = messages[0].version;
        } else {
            this.value = {};
            this.version = -1;
        }
        this.render();
    },
    handleMessages: function(messages){
        _(messages).each(_.bind(function(m){
            if(m.version > this.version){
                this.version = m.version;
                this.last_value = this.value;
                this.value = m;
            }
        },this));
        this.render();
    }
})

IC.makeSingletonConsumer = function(stream){
    var subscriptions = [stream], value;
    value = new IC.SingletonConsumer(subscriptions);
    return value;
}

IC.CollectionConsumer = IC.Consumer.extend({
    initialize: function(subscriptions){
        var filter;
        this.collection = new PourOver.Collection();
        this.view = new PourOver.View("default_ic_view",this.collection);
        filter = PourOver.makeExactFilter("hidden",[true,false,undefined])
        this.collection.addFilters(filter);
        this.collection.filters.hidden.query([false,undefined]);
        this.stream_name = subscriptions[0];
    },
    handleFirstLoad: function(messages){
        messages = _.map(messages, _.bind(function(msg) {
          return this.preprocess(msg);
        },this));
        this.collection.batchLoadItems(messages);
    },
    preprocess: function(i) { return i; },
    handleMessages: function(messages){
        _(messages).each(_.bind(function(msg){
            var guid = msg.guid,
                items = this.collection.getBy("guid",guid) || [],
                item = items[0];
            if(item){
                if(msg.version >= item.version){
                    msg = this.preprocess(msg);
                    this.collection.updateAttributes(item.cid,msg);
                }
            } else {
                msg = this.preprocess(msg);
                this.collection.addItems(msg);
            }
        },this))
    }
})

IC.makeCollectionConsumer = function(stream){
    var subscriptions = [stream], collection;
    collection = new IC.CollectionConsumer(subscriptions);
    return collection;
}

IC.ControlConsumer = IC.CollectionConsumer.extend({
    reload: function(){
        if(window.RELOADING){return}
        var splay = Math.random()*60000;
        console.log("Reloading in ",splay);
        window.RELOADING = true;
        setTimeout(function(){window.location.reload()},splay)
    },
    switchToPolling: function(){
        window._IC_BROKER.switchToPolling();
    },
    toggleUpdates: function(){
        var polling_control = this.collection.getBy("guid","config");
        if(polling_control.length > 0){
            var config = polling_control[0];
            if(config.updates_via === "polling"){
                _IC_BROKER.polling_on = true;
                _IC_BROKER.websocket_on = false;
            } else if (config.updates_via === "none"){
                _IC_BROKER.polling_on = false;
                _IC_BROKER.websocket_on = false;
            } else {
                _IC_BROKER.polling_on = false;
                _IC_BROKER.websocket_on = true;
            }
        }
    }
})
IC.makeControlConsumer = function(stream){
    var subscriptions = [stream];
    controller = new IC.ControlConsumer(subscriptions);
    controller.on("first-load",function(){
        controller.toggleUpdates();

        controller.collection.off("change");
        controller.collection.on("change",function(cids){
            var changed_guids = _(controller.collection.get(cids)).pluck("guid")
            console.log("COLLCHANGE",cids,changed_guids)
            if(_(changed_guids).include("reload")){
                controller.reload();
            }
            if(_(changed_guids).include("config")){
                controller.toggleUpdates();
                _IC_BROKER.resetBroker();
            }
        });


        controller.collection.off("incremental_change");
        controller.collection.on("incremental_change",function(){
            var previous_polling = _IC_BROKER.polling_on,
                previous_websocket = _IC_BROKER.websocket_on;
            controller.toggleUpdates();

            if(previous_polling !== _IC_BROKER.polling_on || previous_websocket !== _IC_BROKER.websocket_on){
                console.log("CONTROL RESET")
                _IC_BROKER.resetBroker();
            }
        });
    });
    return controller;
}


return IC;})
;

</script>
<script type="text/javascript">
    /* global parent, MutationObserver */ // jshint ignore: line

(function() {
    require(['foundation/main'], function() {
        require(['jquery/nyt', 'underscore/nyt', 'ic', 'pourover', 'd3/3'], function($, _, IC, PourOver, d3) {

          // Begin firehose v2-latest

            window._IC_BROKER = new IC.Broker({
              websocket_on: false,
              polling_on: true,
              load_url: "http://int.stg.nyt.com/data/ic/",
              dynamic_fallback_url: "http://invisible-city.adm.stg.newsdev.nytimes.com/ic/state.json"
            });

            var INITIAL_DELAY = 0;

            var DEFAULT_FADE_TIME = 3000;
            var fade_time;
            var f = parseInt(options.fadeTime);
            if (_.isNaN(f) || f === 0) fade_time = DEFAULT_FADE_TIME;
            else fade_time = options.fadeTime * 1000;

            var firehose_consumer = IC.makeCollectionConsumer(options.streamname);

            // depending on the mode, we do different things with the collection
            // "cycle" mode cycles through every few seconds and shows unseen photos first
            // "latest" mode only shows the latest image, and changes when a new one is added
            if (options.mode == 'cycle') {
              var previously_seen_filter = PourOver.makeExactFilter("previously_seen",[true, undefined]);
              firehose_consumer.view.collection.addFilters(previously_seen_filter);
              firehose_consumer.on('first-load', function() {
                var items = firehose_consumer.view.collection.items;
                if (items.length === 0) {
                  console.error('no images in collection');
                  return;
                }
                first_load_cycle_2(fade_time, INITIAL_DELAY);
              });
            } else if (options.mode == 'latest') {
              /** PourOver Sort for "created_at" */
              var created_at_sort = getCreatedAtSort();
              firehose_consumer.view.collection.addSorts([created_at_sort]);
              firehose_consumer.view.setSort('created_at');
              firehose_consumer.on('first-load', function() {
                first_load_latest_2();
              });
            }

            var singleton_consumer = IC.makeSingletonConsumer(options.streamname+":control");
            singleton_consumer.render = _.bind(function(){
                //What's this?
                //The 'first-load' event doesnt emit any data, so it is a bit tricky
                //to populate a view on inital render. The render callback is called
                //on first-load as well as data updated-data, so i added the data-ready
                //event here. this.value is wrapped in an array so callbacks are compatible
                //with updated-data callbacks.
                //this is a place where the simple consumer would prove useful.
                this.trigger("data-ready", [this.value]);
            }, singleton_consumer);
            // simple consumer would be useful here as well
            singleton_consumer.on("data-ready", updateStatus);
            singleton_consumer.register(window._IC_BROKER);
            firehose_consumer.register(window._IC_BROKER);

            $(function() { _IC_BROKER.finalize(); });

            // wait 3 seconds, then remove the loading div
            // $('#loader').delay(INITIAL_DELAY).fadeOut(function() {
            //     $('body').addClass('no-loader');
            // });

            function getCreatedAtSort() {
              var CreatedAtSort =  PourOver.Sort.extend({
                fn: function(a,b) {
                  var field = "created_at";
                  if (a[field] < b[field]) {
                    return -1;
                  } else if (a[field] > b[field]) {
                    return 1;
                  } else {
                    return 0;
                  }
                }
              });
              return new CreatedAtSort('created_at', { associated_attrs: [ 'created_at' ] });
            }

            function first_load_cycle_2(cycle_time, image_delay) {
              var next_cid = get_next_cid();
              loadImageAndCredit(next_cid, function (image, credit) {
                setTimeout(function() {
                  setImageAndCredit(image, credit);
                }, image_delay);
                setTimeout(function() {
                  first_load_cycle_2(cycle_time, 0);
                }, cycle_time);
              });
            }

            // NOTE: For "cycle" or "non-latest" mode only
            // Called when data first available.
            // This function will pre-load first image before
            // the welcome message fades away.
            // Starts recursively calling reader()
            var previous_cid = null;
            function first_load_latest_2() {
              load_and_set_with_delay(INITIAL_DELAY);
              firehose_consumer.collection.on('change', function() {
                load_and_set_with_delay(0);
              });
            }

            function load_and_set_with_delay(delay) {
              get_latest_distinct_cid(function(latest_cid) {
                loadImageAndCredit(latest_cid, function(image, credit) {
                  setTimeout(function() {
                    setImageAndCredit(image, credit);
                  }, delay);
                });
              });
            }

            function get_latest_distinct_cid(callback) {
              var latest_cid = get_latest_cid(firehose_consumer);
              if (latest_cid !== previous_cid) {
                previous_cid = latest_cid;
                callback(latest_cid);
              }
            }

            function loadImageAndCredit(cid, callback) {
              var image_data = firehose_consumer.view.collection.get(cid)[0];
              var guid = image_data["guid"];
              var credit = image_data["nyt_credit"];
              var src = image_url_tpl(guid);
              var img = new Image();
              img.src = src;
              img.href = options.image_href;
              $(img).on('load', function() {
                callback(this, credit);
              });
            }

            function setImageAndCredit(image, credit) {
              d3.selectAll('.placeholder')
                .classed('active', false);
              var activeDiv = setActiveImage(image);
              var creditSpan = activeDiv
                .find('.credit')
                .text(credit);
              positionCreditSpan(image, activeDiv, creditSpan);
              trigger_resize();
            }

            function setActiveImage(image) {
              var src = image.src;
              $(".intrinsic-wrapper").addClass("loaded");
              var active = $('.wc-firehose').find('.active');
              var activeDiv;
              var inactiveDiv;
              if (active.size() === 0 || active.attr('id') === 'photo2') {
                activeDiv = $('#photo1');
                inactiveDiv = $('#photo2');
              } else {
                activeDiv = $('#photo2');
                inactiveDiv = $('#photo1');
              }
              activeDiv.find('.photo')
                .css({'background-image': 'url(' + src + ')'});
              inactiveDiv.removeClass('active');
              activeDiv.addClass('active');
              return activeDiv;
            }

            function positionCreditSpan(image, activeDiv, creditSpan) {
              var imageRatio = image.width / image.height;
              var divWidth = activeDiv.width();
              var divHeight = activeDiv.height();
              var divRatio = divWidth / divHeight;
              var imageHeight, imageWidth, right, bottom;
              if (imageRatio > divRatio) {
                imageHeight = divWidth * (1 / imageRatio);
                bottom = (divHeight - imageHeight) / 2;
                right = 0;
              } else {
                bottom = 0;
                imageWidth = divHeight * imageRatio;
                right = ((divWidth - imageWidth) / 2);
              }
              creditSpan.css({

                bottom: (bottom - 15) + 'px',
                right: (right + 2) + 'px'
              })
            }

            // return the most recent unseen cid (filter previously_seen is undefined), then update cid to set
            // previously_seen as 'true'. If there are no unseen_cids, then return a random seen cid.
            var seen_cids = [];
            function get_next_cid() {
                var unseen_cids = firehose_consumer.view.collection.getFilteredItems("previously_seen",undefined).cids;
                while (unseen_cids.length > 0){
                    var first_cid = _.last(unseen_cids);
                    firehose_consumer.view.collection.updateItem(first_cid, "previously_seen", true);
                    if($.inArray(first_cid, seen_cids) === -1){
                        seen_cids.push(first_cid);
                        return first_cid;
                    }
                    unseen_cids = firehose_consumer.view.collection.getFilteredItems("previously_seen",undefined).cids;
                }
                var random_cid = _.shuffle(seen_cids)[0];
                return random_cid;
            }

            // for "latest" mode only
            function get_latest_cid(_firehose_consumer) {
              var current_items = _firehose_consumer.view.getCurrentItems();
              check_sorted(current_items);
              var latest_cid = _.last(current_items).cid;
              return latest_cid;
            }

             // for "latest" mode only
            function check_sorted(arr) {
              var timestamps = arr
                .map(function(d) { return d.created_at; });
              if (! jortSort(timestamps)) {
                debugger;
                throw new Error('Array is not sorted!');
              }
            }

            // for "latest" mode only
            // checks if the array is sorted properly
            function jortSort( array ) {
              var originalArray = array.slice(0);
              array.sort( function(a,b){return a - b} );
              for (var i = 0; i < originalArray.length; ++i) {
                if (originalArray[i] !== array[i]) {
                  debugger;
                  return false;
                }
              }
              return true;
            }

            /*
            pxl is computed based on the devicePixelRatio as well as the width of the
            responsive image container. Choose the rendition of minimum size that exceeds the pxl value.
            */
            function image_url_tpl(id){
                var pxl = window.devicePixelRatio * $('#photo2 .photo').width();
                var rendition = "300";
                if (pxl>300) rendition = "600";
                if (pxl>600) rendition = "1024";
                // if(pxl>1024) rendition = "2048";
                var tpl = "https://s3.amazonaws.com/int.stg.nyt.com/data/firehose/"+id+"-"+rendition+".jpg";
                return tpl
            }

            function updateStatus(ic_singleton_payload){
                var status = ic_singleton_payload[0]["room_status"]
                $("#firehose-container").removeClass();
                $(".intrinsic-wrapper").removeClass("open closed");
                $("body").removeClass("open closed");
                $("body").addClass(status)
                $(".intrinsic-wrapper").addClass(status);
                $("#firehose-container").addClass(status);

                if(status == "closed" && window.frameElement){
                  $(window.frameElement).height(5);
                }
            }

            function trigger_resize() {
              debug('trigger resize');
              if (d3.select('html').classed('app-interactive')) {
                // $.post('http://696439bd.ngrok.io', "in app");
                var ratio = $(window).width() / $(window).height();
                if (ratio > 1.4) {
                  var height = $(window).height();
                  var width = height * 1.4;
                  d3.select('.intrinsic-wrapper.open')
                    .each(function() {
                      d3.select(this.parentNode)
                        .style('width', width + 'px')
                        .style('margin', '0 auto')
                    })
                }
              }
              else {
                // $.post('http://696439bd.ngrok.io', "not in app");
              }
              require([
                "shared/interactive/instances/app-communicator"
              ], function(AppCommunicator) {
                AppCommunicator.triggerResize();
              });
            }

            function debug(message) {
              console.info('%cDEBUG: ' + '%c' + message, 'color:green;', 'color:black;');
              // foobar
            }

            // Create Share Tools
            function shareTools() {

                var winHeight = screen.height;
                var winWidth = screen.width;

                // Facebook
                window.fbAsyncInit = function() {
                    // init the FB JS SDK
                    FB.init({
                        appId      : '9869919170', // App ID from the App Dashboard
                        status     : false, // check the login status upon init?
                        cookie     : false, // set sessions cookies to allow your server to access the session?
                        xfbml      : false  // parse XFBML tags on this page?
                    });
                };

                // Load the SDK's source Asynchronously
                (function(d, debug){
                    var js, id = 'facebook-jssdk', ref = d.getElementsByTagName('script')[0];
                    if (d.getElementById(id)) {return;}
                    js = d.createElement('script'); js.id = id; js.async = true;
                    js.src = "//connect.facebook.net/en_US/all" + (debug ? "/debug" : "") + ".js";
                    ref.parentNode.insertBefore(js, ref);
                }(document, /*debug*/ false));

                $('.facebook').on('touchstart click', function() {
                    FB.ui({
                        method: 'feed',
                        link: window.location.href,
                        name: options.shareTitle || options.projectTitle,
                        description: options.shareText
                    });
                });


                // Email
                $('.email').on('touchstart click', function() {
                    $(this).one('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend',
                        function() {

                            var width = 900;
                            var height = 590;
                            var windowOptions = 'scrollbars=yes,resizable=yes,toolbar=no,location=no';
                            var left = Math.round((winWidth / 2) - (width / 2));
                            var top = (winHeight > height) ? Math.round((winHeight / 2) - (height / 2)) : 0;
                            window.open("http://www.nytimes.com/mem/email-this.html?url=" + encodeURIComponent(window.location.href), 'emailThis', windowOptions + ',width=' + width + ',height=' + height + ',left=' + left + ',top=' + top);
                    });

                });

                // Twitter
                $('.twitter').on('touchstart click', function() {
                    var url = window.location.href;
                    var via = 'nytimes';
                    var width = 550;
                    var height = 420;
                    var left = Math.round((winWidth / 2) - (width / 2));
                    var top = (winHeight > height) ? Math.round((winHeight / 2) - (height / 2)) : 0;
                    var windowOptions = 'scrollbars=yes,resizable=yes,toolbar=no,location=yes';
                    var text = options.shareText;
                    var target_url = 'https://twitter.com/intent/tweet?';
                    target_url += 'url=' + encodeURIComponent(url);
                    target_url += '&text=' + encodeURIComponent(text);
                    target_url += '&via=' + encodeURIComponent(via);
                    window.open(target_url, 'intent', windowOptions + ',width=' + width + ',height=' + height + ',left=' + left + ',top=' + top);
                });

            }

            shareTools();

        })
    });
})()
;

</script>
